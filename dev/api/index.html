<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library Reference · DataMigrations.jl</title><meta name="title" content="Library Reference · DataMigrations.jl"/><meta property="og:title" content="Library Reference · DataMigrations.jl"/><meta property="twitter:title" content="Library Reference · DataMigrations.jl"/><meta name="description" content="Documentation for DataMigrations.jl."/><meta property="og:description" content="Documentation for DataMigrations.jl."/><meta property="twitter:description" content="Documentation for DataMigrations.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">DataMigrations.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">DataMigrations.jl</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../generated/migrations_intro/">Introduction to Data Migrations</a></li></ul></li><li class="is-active"><a class="tocitem" href>Library Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/AlgebraicJulia/DataMigrations.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/AlgebraicJulia/DataMigrations.jl/blob/main/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Library-Reference"><a class="docs-heading-anchor" href="#Library-Reference">Library Reference</a><a id="Library-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Library-Reference" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataMigrations.DataMigrations" href="#DataMigrations.DataMigrations"><code>DataMigrations.DataMigrations</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>DataMigrations.jl</code></p><p>Extends <code>Catlab.jl</code> with facilities for migrating  acsets (see <code>Acsets.jl</code>) to different  schemas via <em>conjunctive</em>, <em>duc</em>, and <em>gluing</em> queries. Such queries are determined by a functor on the  target schema valued in diagram categories of the target schema.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/DataMigrations.jl/blob/51572ae6bc44e07b397c4f02d26328ee69bce1c6/src/DataMigrations.jl#L2-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataMigrations.Migrations" href="#DataMigrations.Migrations"><code>DataMigrations.Migrations</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Contravariant complex data migrations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/DataMigrations.jl/blob/51572ae6bc44e07b397c4f02d26328ee69bce1c6/src/Migrations.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataMigrations.Migrations.ConjQuery" href="#DataMigrations.Migrations.ConjQuery"><code>DataMigrations.Migrations.ConjQuery</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A conjunctive query over schema <span>$C$</span>.</p><p>When this query is used as part of a call to <code>migrate</code>, the diagram will be composed  with an acset and its limit will then be computed in <span>$Set$</span>.</p><p>See also: <code>GlueQuery</code>, <code>GlucQuery</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/DataMigrations.jl/blob/51572ae6bc44e07b397c4f02d26328ee69bce1c6/src/Migrations.jl#L252-L262">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataMigrations.Migrations.ConjSchemaMigration" href="#DataMigrations.Migrations.ConjSchemaMigration"><code>DataMigrations.Migrations.ConjSchemaMigration</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Schema-level functor defining a contravariant data migration using conjunctive queries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/DataMigrations.jl/blob/51572ae6bc44e07b397c4f02d26328ee69bce1c6/src/Migrations.jl#L305-L307">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataMigrations.Migrations.DataMigration" href="#DataMigrations.Migrations.DataMigration"><code>DataMigrations.Migrations.DataMigration</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A contravariant data migration whose underlying functor <span>$F$</span> may not be fully defined. </p><p>Instead, the migration <code>F⋅X</code> for an acset <code>X</code> can only be constructed once  we have access to <code>X</code>&#39;s attributes and homs. The dictionary of parameters contains anonymous  functions acting on <span>$X$</span>&#39;s attributes using Julia functions defined on  these attribute types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/DataMigrations.jl/blob/51572ae6bc44e07b397c4f02d26328ee69bce1c6/src/Migrations.jl#L287-L294">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataMigrations.Migrations.GlucQuery" href="#DataMigrations.Migrations.GlucQuery"><code>DataMigrations.Migrations.GlucQuery</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>&quot;Gluc query&quot; (gluing of conjunctive queries) over schema <span>$C$</span>.</p><p>The diagram of diagrams comprising the query specifies a finite colimit of finite limits. In the important special case that the outer diagram has discrete shape, it specifies a finite coproduct of finite limits and the query is called a &quot;duc query&quot; (disjoint union of conjunctive queries).</p><p>See also: <code>GlueQuery</code>, <code>GlucQuery</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/DataMigrations.jl/blob/51572ae6bc44e07b397c4f02d26328ee69bce1c6/src/Migrations.jl#L274-L283">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataMigrations.Migrations.GlucSchemaMigration" href="#DataMigrations.Migrations.GlucSchemaMigration"><code>DataMigrations.Migrations.GlucSchemaMigration</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Schema-level functor defining a contravariant data migration using gluc queries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/DataMigrations.jl/blob/51572ae6bc44e07b397c4f02d26328ee69bce1c6/src/Migrations.jl#L315-L317">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataMigrations.Migrations.GlueQuery" href="#DataMigrations.Migrations.GlueQuery"><code>DataMigrations.Migrations.GlueQuery</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Gluing or agglomerative query over schema <span>$C$</span>.</p><p>The diagram comprising the query specifies a finite colimit. In the important special case that the diagram has discrete shape, it specifies a finite coproduct and the query is called &quot;linear&quot; or &quot;disjunctive&quot;.</p><p>See also: <code>ConjQuery</code>, <code>GlucQuery</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/DataMigrations.jl/blob/51572ae6bc44e07b397c4f02d26328ee69bce1c6/src/Migrations.jl#L264-L272">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataMigrations.Migrations.GlueSchemaMigration" href="#DataMigrations.Migrations.GlueSchemaMigration"><code>DataMigrations.Migrations.GlueSchemaMigration</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Schema-level functor defining a contravariant data migration using gluing queries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/DataMigrations.jl/blob/51572ae6bc44e07b397c4f02d26328ee69bce1c6/src/Migrations.jl#L310-L312">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataMigrations.Migrations.QueryDiagram" href="#DataMigrations.Migrations.QueryDiagram"><code>DataMigrations.Migrations.QueryDiagram</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A diagram representing a (conjunctive, duc, gluing, or gluc) query.</p><p>Besides the diagram functor itself, a <code>QueryDiagram</code> contains a  dictionary <code>params</code> of query parameters.  The keys of <code>params</code> are the <code>hom_generators</code> of the target schema <code>C</code> on which the diagram is not fully defined until a migration is executed. The values are either <code>Function</code>s or constants. If <code>Function</code>s, then these values will have one argument for each <code>hom_generator</code> of the target schema <code>D</code>  and return a further function of one argument.</p><p>When an <code>ACSet</code> <span>$X$</span> is migrated via a <code>QueryDiagram</code>,  the <code>Function</code>s in <code>params</code> are evaluated on the  <code>FinDomFunction</code>s in <span>$X$</span>&#39;s range, and the resulting one-variable functions are either pasted directly into the  migrated <code>ACSet</code> <span>$Y$</span>, or else composed with intermediate <code>FinDomFunction</code>s defined by migrating <span>$X$</span> using only the inner <code>diagram</code>. If the keys of <code>params</code> are constants then <span>$Y$</span> will receive constant attributes at the  corresponding values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/DataMigrations.jl/blob/51572ae6bc44e07b397c4f02d26328ee69bce1c6/src/Migrations.jl#L27-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataMigrations.Migrations.QueryDiagram-Union{Tuple{P}, Tuple{D}, Tuple{C}, Tuple{T}, Tuple{D, P}} where {T, C&lt;:Catlab.CategoricalAlgebra.Categories.Category, D&lt;:(Catlab.CategoricalAlgebra.Categories.Functor{&lt;:Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}, C}), P}" href="#DataMigrations.Migrations.QueryDiagram-Union{Tuple{P}, Tuple{D}, Tuple{C}, Tuple{T}, Tuple{D, P}} where {T, C&lt;:Catlab.CategoricalAlgebra.Categories.Category, D&lt;:(Catlab.CategoricalAlgebra.Categories.Functor{&lt;:Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}, C}), P}"><code>DataMigrations.Migrations.QueryDiagram</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">QueryDiagram{T}(F,params)</code></pre><p>Construct a <code>QueryDiagram</code> based on the <code>Functor</code> <code>F</code> and with parameter dictionary <code>params</code>. </p><p>The type parameter <code>T</code> may be <code>id</code>, <code>op</code>, or possibly <code>co</code> or <code>Any</code>, though not all functionality is defined for <code>co</code> and not all functionality is definable for <code>Any</code>. Other type parameters are inferred from  the type of <code>F</code>. The type <code>C</code> of the codomain <code>F</code> will in practice be a subtype of <code>FinCat</code> or of  <code>Diagram</code><code>{T}</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/DataMigrations.jl/blob/51572ae6bc44e07b397c4f02d26328ee69bce1c6/src/Migrations.jl#L54-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataMigrations.Migrations.QueryDiagramHom" href="#DataMigrations.Migrations.QueryDiagramHom"><code>DataMigrations.Migrations.QueryDiagramHom</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A <code>DiagramHom</code> that may be partially-defined, to be evaluated later using the dictionary <code>params</code> of parameters.</p><p>As with <a href="#DataMigrations.Migrations.QueryDiagram"><code>QueryDiagram</code></a>s, <code>params</code> will be a dictionary of <code>Function</code>s or perhaps constants. A <code>QueryDiagramHom</code> is expected to live inside a <a href="#DataMigrations.Migrations.DataMigration"><code>DataMigration</code></a> <code>M</code> and to be fully evaluated whenever <a href="#Catlab.CategoricalAlgebra.FunctorialDataMigrations.migrate-Tuple{Catlab.CategoricalAlgebra.Categories.Functor{Dom} where Dom&lt;:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}), Catlab.CategoricalAlgebra.FunctorialDataMigrations.ContravariantMigration{&lt;:Catlab.CategoricalAlgebra.Categories.Functor{D, &lt;:Catlab.CategoricalAlgebra.Categories.TypeCat{&lt;:Catlab.CategoricalAlgebra.Diagrams.Diagram{AlgebraicInterfaces.id, &lt;:Catlab.CategoricalAlgebra.Categories.TypeCat{&lt;:Catlab.CategoricalAlgebra.Diagrams.Diagram{GATlab.Stdlib.StdModels.op, C}}}}}} where {D&lt;:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}), C&lt;:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})}}"><code>migrate</code></a> is called on <code>M</code> and some <code>ACSet</code> <code>X</code>. </p><p>How this works is that the partially-defined <code>DiagramHom</code> consisting of <code>shape_map</code>, <code>diagram_map</code>, and <code>precomposed_diagram</code> is whiskered with <code>X</code> (except where it&#39;s undefined),  and then the functions in <code>params</code> are used to fill in the gaps.</p><p>See also <a href="#DataMigrations.Migrations.QueryDiagram"><code>QueryDiagram</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/DataMigrations.jl/blob/51572ae6bc44e07b397c4f02d26328ee69bce1c6/src/Migrations.jl#L82-L98">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataMigrations.Migrations.QueryDiagramHom-Union{Tuple{Params}, Tuple{D}, Tuple{Φ}, Tuple{F}, Tuple{C}, Tuple{T}, Tuple{F, Φ, D, Params}} where {T, C, F&lt;:(Catlab.CategoricalAlgebra.Categories.Functor{Dom, Codom} where {Dom&lt;:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}), Codom&lt;:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})}), Φ&lt;:(Catlab.CategoricalAlgebra.Categories.Transformation{C, D, Dom, Codom} where {C&lt;:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}), D&lt;:Catlab.CategoricalAlgebra.Categories.Category, Dom&lt;:(Catlab.CategoricalAlgebra.Categories.Functor{Dom} where Dom&lt;:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})), Codom&lt;:(Catlab.CategoricalAlgebra.Categories.Functor{Dom} where Dom&lt;:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}))}), D&lt;:(Catlab.CategoricalAlgebra.Categories.Functor{&lt;:Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}, C}), Params&lt;:AbstractDict}" href="#DataMigrations.Migrations.QueryDiagramHom-Union{Tuple{Params}, Tuple{D}, Tuple{Φ}, Tuple{F}, Tuple{C}, Tuple{T}, Tuple{F, Φ, D, Params}} where {T, C, F&lt;:(Catlab.CategoricalAlgebra.Categories.Functor{Dom, Codom} where {Dom&lt;:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}), Codom&lt;:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})}), Φ&lt;:(Catlab.CategoricalAlgebra.Categories.Transformation{C, D, Dom, Codom} where {C&lt;:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}), D&lt;:Catlab.CategoricalAlgebra.Categories.Category, Dom&lt;:(Catlab.CategoricalAlgebra.Categories.Functor{Dom} where Dom&lt;:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})), Codom&lt;:(Catlab.CategoricalAlgebra.Categories.Functor{Dom} where Dom&lt;:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}))}), D&lt;:(Catlab.CategoricalAlgebra.Categories.Functor{&lt;:Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}, C}), Params&lt;:AbstractDict}"><code>DataMigrations.Migrations.QueryDiagramHom</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">QueryDiagramHom{T}(shape_map, diagram_map, precomposed_diagram, params)</code></pre><p>Construct a <code>QueryDiagramHom</code> of variance <code>T</code> and fields the given arguments, with further type parameters inferred.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/DataMigrations.jl/blob/51572ae6bc44e07b397c4f02d26328ee69bce1c6/src/Migrations.jl#L106-L111">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataMigrations.Migrations.QueryDiagramHom-Union{Tuple{Params}, Tuple{T}, Tuple{Params, Vararg{Any}}} where {T, Params&lt;:AbstractDict}" href="#DataMigrations.Migrations.QueryDiagramHom-Union{Tuple{Params}, Tuple{T}, Tuple{Params, Vararg{Any}}} where {T, Params&lt;:AbstractDict}"><code>DataMigrations.Migrations.QueryDiagramHom</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">QueryDiagramHom{T}(params,args...)</code></pre><p>Build a <code>QueryDiagramHom</code> with variance <code>T</code> by first building a <code>DiagramHom</code> using <code>args...</code>, then adding the <code>params</code>. </p><p>There are many methods of <code>DiagramHom</code> allowing various calling conventions, and this allows <code>QueryDiagramHom</code> to steal them all reasonably efficiently.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/DataMigrations.jl/blob/51572ae6bc44e07b397c4f02d26328ee69bce1c6/src/Migrations.jl#L127-L135">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicInterfaces.compose-Union{Tuple{T}, Tuple{DiagramHom{T}, Catlab.CategoricalAlgebra.Categories.Functor, Any}} where T" href="#AlgebraicInterfaces.compose-Union{Tuple{T}, Tuple{DiagramHom{T}, Catlab.CategoricalAlgebra.Categories.Functor, Any}} where T"><code>AlgebraicInterfaces.compose</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compose(f::DiagramHom,F::Functor,params[;kw...])</code></pre><p>Whisker a partially-defined <code>DiagramHom</code> with a  <code>Functor</code>, using the dictionary <code>params</code> to fill in any gaps. </p><p>While <a href="#DataMigrations.Migrations.QueryDiagramHom"><code>QueryDiagramHom</code></a>s have internal <code>params</code> for a similar purpose, it is sometimes necessary to borrow <code>params</code> from a <a href="#DataMigrations.Migrations.QueryDiagram"><code>QueryDiagram</code></a> containing <code>f</code>, which is the functionality enabled here.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/DataMigrations.jl/blob/51572ae6bc44e07b397c4f02d26328ee69bce1c6/src/Migrations.jl#L178-L188">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AlgebraicInterfaces.compose-Union{Tuple{T}, Tuple{QueryDiagram{T, C} where C&lt;:Catlab.CategoricalAlgebra.Categories.Category, Catlab.CategoricalAlgebra.Categories.Functor}} where T" href="#AlgebraicInterfaces.compose-Union{Tuple{T}, Tuple{QueryDiagram{T, C} where C&lt;:Catlab.CategoricalAlgebra.Categories.Category, Catlab.CategoricalAlgebra.Categories.Functor}} where T"><code>AlgebraicInterfaces.compose</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compose(d::QueryDiagram,F::Functor[;kw...])</code></pre><p>Lazily compose a diagram with parameters (see <a href="#DataMigrations.Migrations.QueryDiagram">QueryDiagram</a>)  with a <code>Functor</code>. </p><p>The result is not evaluated, so the  returned <code>QueryDiagram</code> may remain partially defined with parameters  still to be filled in.</p><p>See also: <code>force</code>, <code>QueryDiagram</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/DataMigrations.jl/blob/51572ae6bc44e07b397c4f02d26328ee69bce1c6/src/Migrations.jl#L196-L207">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.force" href="#Catlab.CategoricalAlgebra.FinCats.force"><code>Catlab.CategoricalAlgebra.FinCats.force</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">force(F::FinDomFunctor,params,[Obtype=Any,Homtype=Any])</code></pre><p>Force-evaluate a partially-defined <code>FinDomFunctor</code> by using <code>Function</code>s in <code>params</code> to fill in undefined  entries of <code>F</code>&#39;s <code>hom_map</code>.</p><p>If <code>Obtype</code> and <code>Homtype</code> are specified, then the returned functor is guaranteed to have exactly those value types in its <code>ob_map</code> and <code>hom_map</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/DataMigrations.jl/blob/51572ae6bc44e07b397c4f02d26328ee69bce1c6/src/Migrations.jl#L229-L239">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FinCats.force-Union{Tuple{T}, Tuple{QueryDiagram{T, C} where C&lt;:Catlab.CategoricalAlgebra.Categories.Category, Vararg{Any}}} where T" href="#Catlab.CategoricalAlgebra.FinCats.force-Union{Tuple{T}, Tuple{QueryDiagram{T, C} where C&lt;:Catlab.CategoricalAlgebra.Categories.Category, Vararg{Any}}} where T"><code>Catlab.CategoricalAlgebra.FinCats.force</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">force(d::QueryDiagram,[args...])</code></pre><p>Force-evaluate the <code>d.diagram</code> for a <code>QueryDiagram</code> <code>d</code>.</p><p>The result is a <code>SimpleDiagram</code>, and in particular the inner call to <code>force</code> attempts to use <code>d.params</code> to produce a fully-defined <code>FinDomFunctor</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/DataMigrations.jl/blob/51572ae6bc44e07b397c4f02d26328ee69bce1c6/src/Migrations.jl#L70-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Catlab.CategoricalAlgebra.FunctorialDataMigrations.migrate-Tuple{Catlab.CategoricalAlgebra.Categories.Functor{Dom} where Dom&lt;:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}), Catlab.CategoricalAlgebra.FunctorialDataMigrations.ContravariantMigration{&lt;:Catlab.CategoricalAlgebra.Categories.Functor{D, &lt;:Catlab.CategoricalAlgebra.Categories.TypeCat{&lt;:Catlab.CategoricalAlgebra.Diagrams.Diagram{AlgebraicInterfaces.id, &lt;:Catlab.CategoricalAlgebra.Categories.TypeCat{&lt;:Catlab.CategoricalAlgebra.Diagrams.Diagram{GATlab.Stdlib.StdModels.op, C}}}}}} where {D&lt;:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}), C&lt;:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})}}" href="#Catlab.CategoricalAlgebra.FunctorialDataMigrations.migrate-Tuple{Catlab.CategoricalAlgebra.Categories.Functor{Dom} where Dom&lt;:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}), Catlab.CategoricalAlgebra.FunctorialDataMigrations.ContravariantMigration{&lt;:Catlab.CategoricalAlgebra.Categories.Functor{D, &lt;:Catlab.CategoricalAlgebra.Categories.TypeCat{&lt;:Catlab.CategoricalAlgebra.Diagrams.Diagram{AlgebraicInterfaces.id, &lt;:Catlab.CategoricalAlgebra.Categories.TypeCat{&lt;:Catlab.CategoricalAlgebra.Diagrams.Diagram{GATlab.Stdlib.StdModels.op, C}}}}}} where {D&lt;:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}), C&lt;:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})}}"><code>Catlab.CategoricalAlgebra.FunctorialDataMigrations.migrate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">migrate(M,X)</code></pre><p>do the dang migration</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/DataMigrations.jl/blob/51572ae6bc44e07b397c4f02d26328ee69bce1c6/src/Migrations.jl#L452-L456">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataMigrations.Migrations.colimit_representables-Tuple{Catlab.CategoricalAlgebra.FunctorialDataMigrations.ContravariantMigration{F} where F&lt;:(Catlab.CategoricalAlgebra.Categories.Functor{Dom, Codom} where {Dom&lt;:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}), Codom&lt;:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})}), Any}" href="#DataMigrations.Migrations.colimit_representables-Tuple{Catlab.CategoricalAlgebra.FunctorialDataMigrations.ContravariantMigration{F} where F&lt;:(Catlab.CategoricalAlgebra.Categories.Functor{Dom, Codom} where {Dom&lt;:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}), Codom&lt;:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})}), Any}"><code>DataMigrations.Migrations.colimit_representables</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Interpret conjunctive data migration as a colimit of representables.</p><p>Given a conjunctive data migration (a functor <code>J → Diag{op}(C)</code>) and the Yoneda embedding for <code>C</code> (a functor <code>op(C) → C-Set</code> computed via <code>yoneda</code>), take colimits of representables to construct a <code>op(J)</code>-shaped diagram of C-sets.</p><p>Since every C-set is a colimit of representables, this is a generic way of constructing diagrams of C-sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/DataMigrations.jl/blob/51572ae6bc44e07b397c4f02d26328ee69bce1c6/src/Migrations.jl#L493-L502">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataMigrations.Migrations.get_params-Tuple{QueryDiagramHom}" href="#DataMigrations.Migrations.get_params-Tuple{QueryDiagramHom}"><code>DataMigrations.Migrations.get_params</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_params(f::DiagramHom)</code></pre><p>Get the parameters of <code>f</code>, if <code>f</code> is a <code>QueryDiagramHom</code>. Otherwise return an empty <code>Dict</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/DataMigrations.jl/blob/51572ae6bc44e07b397c4f02d26328ee69bce1c6/src/Migrations.jl#L118-L123">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataMigrations.Migrations.get_src_schema-Tuple{Catlab.CategoricalAlgebra.Categories.Functor{&lt;:Catlab.CategoricalAlgebra.Categories.Category, &lt;:Catlab.CategoricalAlgebra.Categories.TypeCat{&lt;:Catlab.CategoricalAlgebra.Diagrams.Diagram}}}" href="#DataMigrations.Migrations.get_src_schema-Tuple{Catlab.CategoricalAlgebra.Categories.Functor{&lt;:Catlab.CategoricalAlgebra.Categories.Category, &lt;:Catlab.CategoricalAlgebra.Categories.TypeCat{&lt;:Catlab.CategoricalAlgebra.Diagrams.Diagram}}}"><code>DataMigrations.Migrations.get_src_schema</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Get the source schema of a data migration functor, recursing in the case that the proximate codomain is a diagram category.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/DataMigrations.jl/blob/51572ae6bc44e07b397c4f02d26328ee69bce1c6/src/Migrations.jl#L352-L355">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataMigrations.Migrations.param_compose-Tuple{Catlab.CategoricalAlgebra.Categories.Transformation{C, D, Dom, Codom} where {C&lt;:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}), D&lt;:Catlab.CategoricalAlgebra.Categories.Category, Dom&lt;:(Catlab.CategoricalAlgebra.Categories.Functor{Dom} where Dom&lt;:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})), Codom&lt;:(Catlab.CategoricalAlgebra.Categories.Functor{Dom} where Dom&lt;:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}))}, Catlab.CategoricalAlgebra.Categories.Functor, Any}" href="#DataMigrations.Migrations.param_compose-Tuple{Catlab.CategoricalAlgebra.Categories.Transformation{C, D, Dom, Codom} where {C&lt;:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}), D&lt;:Catlab.CategoricalAlgebra.Categories.Category, Dom&lt;:(Catlab.CategoricalAlgebra.Categories.Functor{Dom} where Dom&lt;:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})), Codom&lt;:(Catlab.CategoricalAlgebra.Categories.Functor{Dom} where Dom&lt;:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}))}, Catlab.CategoricalAlgebra.Categories.Functor, Any}"><code>DataMigrations.Migrations.param_compose</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">param_compose(α,H,params)</code></pre><p>Whisker a partially natural transformation <code>α</code> with a functor <code>H</code>, given any needed parameters <code>params</code> specifying the functions in  <code>H</code>&#39;s codomain which the whiskered result should map to. </p><p>Currently assumes the result will be a totally defined transformation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/DataMigrations.jl/blob/51572ae6bc44e07b397c4f02d26328ee69bce1c6/src/Migrations.jl#L146-L154">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataMigrations.DiagrammaticPrograms.@acset_colim-Tuple{Any, Any}" href="#DataMigrations.DiagrammaticPrograms.@acset_colim-Tuple{Any, Any}"><code>DataMigrations.DiagrammaticPrograms.@acset_colim</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Uses the output of <code>yoneda</code>:</p><p>@acset_colim yGraph begin    (e1,e2)::E    src(e1) == tgt(e2)  end</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/DataMigrations.jl/blob/51572ae6bc44e07b397c4f02d26328ee69bce1c6/src/DiagrammaticPrograms.jl#L642-L649">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataMigrations.DiagrammaticPrograms.@diagram-Tuple{Any, Any}" href="#DataMigrations.DiagrammaticPrograms.@diagram-Tuple{Any, Any}"><code>DataMigrations.DiagrammaticPrograms.@diagram</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Present a diagram in a given category.</p><p>Recall that a <em>diagram</em> in a category <span>$C$</span> is a functor <span>$F: J → C$</span> from a small category <span>$J$</span> into <span>$C$</span>. Given the category <span>$C$</span>, this macro presents a diagram in <span>$C$</span>, i.e., constructs a finitely presented indexing category <span>$J$</span> together with a functor <span>$F: J → C$</span>. This method of simultaneous definition is often more convenient than defining <span>$J$</span> and <span>$F$</span> separately, as could be accomplished by calling <a href="#DataMigrations.DiagrammaticPrograms.@fincat-Tuple{Any}"><code>@fincat</code></a> and then <a href="#DataMigrations.DiagrammaticPrograms.@finfunctor-NTuple{4, Any}"><code>@finfunctor</code></a>.</p><p>As an example, the limit of the following diagram consists of the paths of length two in a graph:</p><pre><code class="language-julia hljs">@diagram SchGraph begin
  v::V
  (e₁, e₂)::E
  (t: e₁ → v)::tgt
  (s: e₂ → v)::src
end</code></pre><p>Morphisms in the indexing category can be left unnamed, which is convenient for defining free diagrams (see also <a href="#DataMigrations.DiagrammaticPrograms.@free_diagram-Tuple{Any, Any}"><code>@free_diagram</code></a>). For example, the following diagram is isomorphic to the previous one:</p><pre><code class="language-julia hljs">@diagram SchGraph begin
  v::V
  (e₁, e₂)::E
  (e₁ → v)::tgt
  (e₂ → v)::src
end</code></pre><p>Of course, unnamed morphisms cannot be referenced by name within the <code>@diagram</code> call or in other settings, which can sometimes be problematic.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/DataMigrations.jl/blob/51572ae6bc44e07b397c4f02d26328ee69bce1c6/src/DiagrammaticPrograms.jl#L393-L430">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataMigrations.DiagrammaticPrograms.@fincat-Tuple{Any}" href="#DataMigrations.DiagrammaticPrograms.@fincat-Tuple{Any}"><code>DataMigrations.DiagrammaticPrograms.@fincat</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Present a category by generators and relations.</p><p>The result is a finitely presented category (<code>FinCat</code>) represented by a graph, possibly with path equations. For example, the simplex category truncated to one dimension is:</p><pre><code class="language-julia hljs">@fincat begin
  V, E
  (δ₀, δ₁): V → E
  σ₀: E → V

  σ₀ ∘ δ₀ == id(V)
  σ₀ ∘ δ₁ == id(V)
end</code></pre><p>The objects and morphisms must be uniquely named.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/DataMigrations.jl/blob/51572ae6bc44e07b397c4f02d26328ee69bce1c6/src/DiagrammaticPrograms.jl#L168-L188">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataMigrations.DiagrammaticPrograms.@finfunctor-NTuple{4, Any}" href="#DataMigrations.DiagrammaticPrograms.@finfunctor-NTuple{4, Any}"><code>DataMigrations.DiagrammaticPrograms.@finfunctor</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Define a functor between two finitely presented categories.</p><p>Such a functor is defined by sending the object and morphism generators of the domain category to generic object and morphism expressions in the codomain category. For example, the following functor embeds the schema for graphs into the schema for circular port graphs by ignoring the ports:</p><pre><code class="language-julia hljs">@finfunctor SchGraph SchCPortGraph begin
  V =&gt; Box
  E =&gt; Wire
  src =&gt; src ⨟ box
  tgt =&gt; tgt ⨟ box
end</code></pre><p>A constructor exists that purports to allow the user to check that a proposed functor satisfies relations in the domain, but this functionality doesn&#39;t yet exist (and the problem is undecidable in general.) Thus the only check is that the source and target of the image of an arrow are the image of its source and target.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/DataMigrations.jl/blob/51572ae6bc44e07b397c4f02d26328ee69bce1c6/src/DiagrammaticPrograms.jl#L214-L236">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataMigrations.DiagrammaticPrograms.@free_diagram-Tuple{Any, Any}" href="#DataMigrations.DiagrammaticPrograms.@free_diagram-Tuple{Any, Any}"><code>DataMigrations.DiagrammaticPrograms.@free_diagram</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Present a free diagram in a given category.</p><p>Recall that a <em>free diagram</em> in a category <span>$C$</span> is a functor <span>$F: J → C$</span> where <span>$J$</span> is a free category on a graph, here assumed finite. This macro is functionally a special case of <a href="#DataMigrations.DiagrammaticPrograms.@diagram-Tuple{Any, Any}"><code>@diagram</code></a> but changes the interpretation of equality expressions. Rather than interpreting them as equations between morphisms in <span>$J$</span>, equality expresions can be used to introduce anonymous morphisms in a &quot;pointful&quot; style. For example, the limit of the following diagram consists of the paths of length two in a graph:</p><pre><code class="language-julia hljs">@free_diagram SchGraph begin
  v::V
  (e₁, e₂)::E
  tgt(e₁) == v
  src(e₂) == v
end</code></pre><p>Anonymous objects can also be introduced. For example, the previous diagram is isomorphic to this one:</p><pre><code class="language-julia hljs">@free_diagram SchGraph begin
  (e₁, e₂)::E
  tgt(e₁) == src(e₂)
end</code></pre><p>Some care must exercised when defining morphisms between diagrams with anonymous objects, since they cannot be referred to by name.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/DataMigrations.jl/blob/51572ae6bc44e07b397c4f02d26328ee69bce1c6/src/DiagrammaticPrograms.jl#L435-L467">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataMigrations.DiagrammaticPrograms.@graph-Tuple{Any, Any}" href="#DataMigrations.DiagrammaticPrograms.@graph-Tuple{Any, Any}"><code>DataMigrations.DiagrammaticPrograms.@graph</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Construct a graph in a simple, declarative style.</p><p>The syntax is reminiscent of Graphviz. Each line a declares a vertex or set of vertices, or an edge. For example, the following defines a directed triangle:</p><pre><code class="language-julia hljs">@graph begin
  v0, v1, v2
  fst: v0 → v1
  snd: v1 → v2
  comp: v0 → v2
end</code></pre><p>Vertices in the graph must be uniquely named, whereas edges names are optional.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/DataMigrations.jl/blob/51572ae6bc44e07b397c4f02d26328ee69bce1c6/src/DiagrammaticPrograms.jl#L113-L129">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataMigrations.DiagrammaticPrograms.@migrate-Tuple{Any, Any, Any}" href="#DataMigrations.DiagrammaticPrograms.@migrate-Tuple{Any, Any, Any}"><code>DataMigrations.DiagrammaticPrograms.@migrate</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Contravariantly migrate data from one acset to another.</p><p>This macro is shorthand for defining a data migration using the <a href="#DataMigrations.DiagrammaticPrograms.@migration-Tuple{Any, Any}"><code>@migration</code></a> macro and then calling the <code>migrate</code> function. If the migration will be used multiple times, it is more efficient to perform these steps separately, reusing the functor defined by <code>@migration</code>.</p><p>For more about the syntax and supported features, see <a href="#DataMigrations.DiagrammaticPrograms.@migration-Tuple{Any, Any}"><code>@migration</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/DataMigrations.jl/blob/51572ae6bc44e07b397c4f02d26328ee69bce1c6/src/DiagrammaticPrograms.jl#L564-L573">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataMigrations.DiagrammaticPrograms.@migration-Tuple{Any, Any}" href="#DataMigrations.DiagrammaticPrograms.@migration-Tuple{Any, Any}"><code>DataMigrations.DiagrammaticPrograms.@migration</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Define a contravariant data migration.</p><p>This macro provides a DSL to specify a contravariant data migration from <span>$C$</span>-sets to <span>$D$</span>-sets for given schemas <span>$C$</span> and <span>$D$</span>. A data migration is defined by a functor from <span>$D$</span> to a category of queries on <span>$C$</span>. Thus, every object of <span>$D$</span> is assigned a query on <span>$C$</span> and every morphism of <span>$D$</span> is assigned a morphism of queries, in a compatible way. Example usages are in the unit tests. What follows is a technical reference.</p><p>Several categories of queries are supported by this macro:</p><ol><li>Trivial queries, specified by a single object of <span>$C$</span>. In this case, the macro simply defines a functor <span>$D → C$</span> and is equivalent to <a href="#DataMigrations.DiagrammaticPrograms.@finfunctor-NTuple{4, Any}"><code>@finfunctor</code></a> or <a href="#DataMigrations.DiagrammaticPrograms.@diagram-Tuple{Any, Any}"><code>@diagram</code></a>.</li><li><em>Conjunctive queries</em>, specified by a diagram in <span>$C$</span> and evaluated as a finite limit.</li><li><em>Gluing queries</em>, specified by a diagram in <span>$C$</span> and evaluated as a finite colimit. An important special case is <em>linear queries</em>, evaluated as a finite coproduct.</li><li><em>Gluc queries</em> (gluings of conjunctive queries), specified by a diagram of diagrams in <span>$C$</span> and evaluated as a colimit of limits. An important special case is <em>duc queries</em> (disjoint unions of conjunctive queries), evaluated as a coproduct of limits.</li></ol><p>The query category of the data migration is not specified explicitly but is inferred from the queries used in the macro call. Implicit conversion is performed: trivial queries can be coerced to conjunctive queries or gluing queries, and conjunctive queries and gluing queries can both be coerced to gluc queries. Due to the implicit conversion, the resulting functor out of <span>$D$</span> has a single query type and thus a well-defined codomain.</p><p>Syntax for the right-hand sides of object assignments is:</p><ul><li>a symbol, giving object of <span>$C$</span> (query type: trivial)</li><li><code>@product ...</code> (query type: conjunctive)</li><li><code>@unit</code> (alias: <code>@terminal</code>, query type: conjunctive)</li><li><code>@join ...</code> (alias: <code>@limit</code>, query type: conjunctive)</li><li><code>@cases ...</code> (alias: <code>@coproduct</code>, query type: gluing)</li><li><code>@empty</code> (alias: <code>@initial</code>, query type: gluing)</li><li><code>@glue ...</code> (alias: <code>@colimit</code>, query type: gluing)</li></ul><p>Thes query types supported by this macro generalize the kind of queries familiar from relational databases. Less familiar is the concept of a morphism between queries, derived from the concept of a morphism between diagrams in a category. A query morphism is given by a functor between the diagrams&#39; indexing categories together with a natural transformation filling a triangle of the appropriate shape. From a practical standpoint, the most important thing to remember is that a morphism between conjunctive queries is contravariant with respect to the diagram shapes, whereas a morphism between gluing queries is covariant. TODO: Reference for more on this.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AlgebraicJulia/DataMigrations.jl/blob/51572ae6bc44e07b397c4f02d26328ee69bce1c6/src/DiagrammaticPrograms.jl#L582-L633">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../generated/migrations_intro/">« Introduction to Data Migrations</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.2 on <span class="colophon-date" title="Friday 25 April 2025 20:11">Friday 25 April 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
