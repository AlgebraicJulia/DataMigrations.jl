<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Introduction to Data Migrations · DataMigrations.jl</title><meta name="title" content="Introduction to Data Migrations · DataMigrations.jl"/><meta property="og:title" content="Introduction to Data Migrations · DataMigrations.jl"/><meta property="twitter:title" content="Introduction to Data Migrations · DataMigrations.jl"/><meta name="description" content="Documentation for DataMigrations.jl."/><meta property="og:description" content="Documentation for DataMigrations.jl."/><meta property="twitter:description" content="Documentation for DataMigrations.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DataMigrations.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">DataMigrations.jl</a></li><li><span class="tocitem">Examples</span><ul><li class="is-active"><a class="tocitem" href>Introduction to Data Migrations</a></li></ul></li><li><a class="tocitem" href="../../api/">Library Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Introduction to Data Migrations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Introduction to Data Migrations</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/AlgebraicJulia/DataMigrations.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/AlgebraicJulia/DataMigrations.jl/blob/main/docs/literate/migrations_intro.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Introduction-to-Data-Migrations"><a class="docs-heading-anchor" href="#Introduction-to-Data-Migrations">Introduction to Data Migrations</a><a id="Introduction-to-Data-Migrations-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction-to-Data-Migrations" title="Permalink"></a></h1><p>DataMigrations.jl includes facilities for categorical data migrations. We&#39;ll start by example, working with some graph schemas from Catlab.</p><pre><code class="language-julia hljs">using Catlab, DataMigrations
M = @migration SchReflexiveGraph SchGraph begin
  V =&gt; V
  E =&gt; @cases begin e::E; v::V end
  src =&gt; begin e =&gt; src; v =&gt; id(V) end
  tgt =&gt; begin e =&gt; tgt; v =&gt; id(V) end
  refl =&gt; v
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">DataMigration{Catlab.CategoricalAlgebra.FinCats.FinDomFunctorMap{Catlab.CategoricalAlgebra.FinCats.FinCatPresentation{Catlab.Theories.ThSchema.Meta.T, Union{Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Ob}, Union{Catlab.Theories.FreeSchema.Attr, Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Hom}}, Catlab.CategoricalAlgebra.Categories.TypeCat{Catlab.CategoricalAlgebra.Diagrams.SimpleDiagram{AlgebraicInterfaces.id, Catlab.CategoricalAlgebra.FinCats.FinCatPresentation{Catlab.Theories.ThSchema.Meta.T, Union{Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Ob}, Union{Catlab.Theories.FreeSchema.Attr, Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Hom}}, D} where D&lt;:(Catlab.CategoricalAlgebra.Categories.Functor{&lt;:Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}, Catlab.CategoricalAlgebra.FinCats.FinCatPresentation{Catlab.Theories.ThSchema.Meta.T, Union{Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Ob}, Union{Catlab.Theories.FreeSchema.Attr, Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Hom}}}), QueryDiagramHom{AlgebraicInterfaces.id, Catlab.CategoricalAlgebra.FinCats.FinCatPresentation{Catlab.Theories.ThSchema.Meta.T, Union{Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Ob}, Union{Catlab.Theories.FreeSchema.Attr, Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Hom}}, Catlab.CategoricalAlgebra.FinCats.FinDomFunctorMap{Catlab.CategoricalAlgebra.FinCats.FinCatPresentation{Catlab.Theories.ThSchema.Meta.T, Union{Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Ob}, Union{Catlab.Theories.FreeSchema.Attr, Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Hom}}, Catlab.CategoricalAlgebra.FinCats.FinCatPresentation{Catlab.Theories.ThSchema.Meta.T, Union{Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Ob}, Union{Catlab.Theories.FreeSchema.Attr, Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Hom}}, Dict{Symbol, Catlab.Theories.FreeSchema.Ob{:generator}}, Dict{Any, Any}}, Φ, D} where {Φ&lt;:(Catlab.CategoricalAlgebra.Categories.Transformation{C, D, Dom, Codom} where {C&lt;:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}), D&lt;:Catlab.CategoricalAlgebra.Categories.Category, Dom&lt;:(Catlab.CategoricalAlgebra.Categories.Functor{Dom} where Dom&lt;:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})), Codom&lt;:(Catlab.CategoricalAlgebra.Categories.Functor{Dom} where Dom&lt;:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}))}), D&lt;:(Catlab.CategoricalAlgebra.Categories.Functor{&lt;:Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}, Catlab.CategoricalAlgebra.FinCats.FinCatPresentation{Catlab.Theories.ThSchema.Meta.T, Union{Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Ob}, Union{Catlab.Theories.FreeSchema.Attr, Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Hom}}})}}, Dict{Symbol, Catlab.CategoricalAlgebra.Diagrams.SimpleDiagram{AlgebraicInterfaces.id, Catlab.CategoricalAlgebra.FinCats.FinCatPresentation{Catlab.Theories.ThSchema.Meta.T, Union{Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Ob}, Union{Catlab.Theories.FreeSchema.Attr, Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Hom}}, D} where D&lt;:(Catlab.CategoricalAlgebra.Categories.Functor{&lt;:Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}, Catlab.CategoricalAlgebra.FinCats.FinCatPresentation{Catlab.Theories.ThSchema.Meta.T, Union{Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Ob}, Union{Catlab.Theories.FreeSchema.Attr, Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Hom}}})}, Dict{Symbol, QueryDiagramHom{AlgebraicInterfaces.id, Catlab.CategoricalAlgebra.FinCats.FinCatPresentation{Catlab.Theories.ThSchema.Meta.T, Union{Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Ob}, Union{Catlab.Theories.FreeSchema.Attr, Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Hom}}, Catlab.CategoricalAlgebra.FinCats.FinDomFunctorMap{Catlab.CategoricalAlgebra.FinCats.FinCatPresentation{Catlab.Theories.ThSchema.Meta.T, Union{Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Ob}, Union{Catlab.Theories.FreeSchema.Attr, Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Hom}}, Catlab.CategoricalAlgebra.FinCats.FinCatPresentation{Catlab.Theories.ThSchema.Meta.T, Union{Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Ob}, Union{Catlab.Theories.FreeSchema.Attr, Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Hom}}, Dict{Symbol, Catlab.Theories.FreeSchema.Ob{:generator}}, Dict{Any, Any}}, Φ, D} where {Φ&lt;:(Catlab.CategoricalAlgebra.Categories.Transformation{C, D, Dom, Codom} where {C&lt;:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}), D&lt;:Catlab.CategoricalAlgebra.Categories.Category, Dom&lt;:(Catlab.CategoricalAlgebra.Categories.Functor{Dom} where Dom&lt;:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})), Codom&lt;:(Catlab.CategoricalAlgebra.Categories.Functor{Dom} where Dom&lt;:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}))}), D&lt;:(Catlab.CategoricalAlgebra.Categories.Functor{&lt;:Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}, Catlab.CategoricalAlgebra.FinCats.FinCatPresentation{Catlab.Theories.ThSchema.Meta.T, Union{Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Ob}, Union{Catlab.Theories.FreeSchema.Attr, Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Hom}}})}}}, Dict{Any, Union{}}}(FinDomFunctor(Dict{Symbol, Catlab.CategoricalAlgebra.Diagrams.SimpleDiagram{AlgebraicInterfaces.id, Catlab.CategoricalAlgebra.FinCats.FinCatPresentation{Catlab.Theories.ThSchema.Meta.T, Union{Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Ob}, Union{Catlab.Theories.FreeSchema.Attr, Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Hom}}, D} where D&lt;:(Catlab.CategoricalAlgebra.Categories.Functor{&lt;:Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}, Catlab.CategoricalAlgebra.FinCats.FinCatPresentation{Catlab.Theories.ThSchema.Meta.T, Union{Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Ob}, Union{Catlab.Theories.FreeSchema.Attr, Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Hom}}})}(:V =&gt; Diagram{id}(FinFunctor(Dict{Symbol, Catlab.Theories.FreeSchema.Ob{:generator}}(:V =&gt; V), Dict{Symbol, Union{Catlab.Theories.FreeSchema.Attr, Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Hom}}(), FinCat(Presentation{T, Symbol}(Catlab.Theories.FreeSchema, (Ob = Ob{:generator}[V], Hom = Hom{:generator}[], AttrType = AttrType{:generator}[], Attr = Attr{:generator}[]), Dict(:V=&gt;(:Ob=&gt;1)), Pair[])), FinCat(Presentation{T, Symbol}(Catlab.Theories.FreeSchema, (Ob = Ob{:generator}[V, E], Hom = Hom{:generator}[src, tgt], AttrType = AttrType{:generator}[], Attr = Attr{:generator}[]), Dict(:src=&gt;(:Hom=&gt;1), :V=&gt;(:Ob=&gt;1), :E=&gt;(:Ob=&gt;2), :tgt=&gt;(:Hom=&gt;2)), Pair[])))), :E =&gt; Diagram{id}(FinFunctor(Dict{Symbol, Catlab.Theories.FreeSchema.Ob{:generator}}(:v =&gt; V, :e =&gt; E), Dict{Any, Any}(), FinCat(Presentation{T, Symbol}(Catlab.Theories.FreeSchema, (Ob = Ob{:generator}[e, v], Hom = Hom{:generator}[], AttrType = AttrType{:generator}[], Attr = Attr{:generator}[]), Dict(:e=&gt;(:Ob=&gt;1), :v=&gt;(:Ob=&gt;2)), Pair[])), FinCat(Presentation{T, Symbol}(Catlab.Theories.FreeSchema, (Ob = Ob{:generator}[V, E], Hom = Hom{:generator}[src, tgt], AttrType = AttrType{:generator}[], Attr = Attr{:generator}[]), Dict(:src=&gt;(:Hom=&gt;1), :V=&gt;(:Ob=&gt;1), :E=&gt;(:Ob=&gt;2), :tgt=&gt;(:Hom=&gt;2)), Pair[]))))), Dict{Symbol, QueryDiagramHom{AlgebraicInterfaces.id, Catlab.CategoricalAlgebra.FinCats.FinCatPresentation{Catlab.Theories.ThSchema.Meta.T, Union{Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Ob}, Union{Catlab.Theories.FreeSchema.Attr, Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Hom}}, Catlab.CategoricalAlgebra.FinCats.FinDomFunctorMap{Catlab.CategoricalAlgebra.FinCats.FinCatPresentation{Catlab.Theories.ThSchema.Meta.T, Union{Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Ob}, Union{Catlab.Theories.FreeSchema.Attr, Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Hom}}, Catlab.CategoricalAlgebra.FinCats.FinCatPresentation{Catlab.Theories.ThSchema.Meta.T, Union{Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Ob}, Union{Catlab.Theories.FreeSchema.Attr, Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Hom}}, Dict{Symbol, Catlab.Theories.FreeSchema.Ob{:generator}}, Dict{Any, Any}}, Φ, D} where {Φ&lt;:(Catlab.CategoricalAlgebra.Categories.Transformation{C, D, Dom, Codom} where {C&lt;:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}), D&lt;:Catlab.CategoricalAlgebra.Categories.Category, Dom&lt;:(Catlab.CategoricalAlgebra.Categories.Functor{Dom} where Dom&lt;:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})), Codom&lt;:(Catlab.CategoricalAlgebra.Categories.Functor{Dom} where Dom&lt;:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}))}), D&lt;:(Catlab.CategoricalAlgebra.Categories.Functor{&lt;:Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}, Catlab.CategoricalAlgebra.FinCats.FinCatPresentation{Catlab.Theories.ThSchema.Meta.T, Union{Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Ob}, Union{Catlab.Theories.FreeSchema.Attr, Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Hom}}})}}(:refl =&gt; DiagramHom{id}([(v, id(V))], [], FinFunctor(Dict{Symbol, Ob{:generator}}(:V=&gt;V), Dict{Symbol, Union{Attr, AttrType, Hom}}(), …), FinFunctor(Dict{Symbol, Ob{:generator}}(:v=&gt;V, :e=&gt;E), Dict{Any, Any}(), …)), :src =&gt; DiagramHom{id}([(V, src), (V, id(V))], [], FinFunctor(Dict{Symbol, Ob{:generator}}(:v=&gt;V, :e=&gt;E), Dict{Any, Any}(), …), FinFunctor(Dict{Symbol, Ob{:generator}}(:V=&gt;V), Dict{Symbol, Union{Attr, AttrType, Hom}}(), …)), :tgt =&gt; DiagramHom{id}([(V, tgt), (V, id(V))], [], FinFunctor(Dict{Symbol, Ob{:generator}}(:v=&gt;V, :e=&gt;E), Dict{Any, Any}(), …), FinFunctor(Dict{Symbol, Ob{:generator}}(:V=&gt;V), Dict{Symbol, Union{Attr, AttrType, Hom}}(), …))), FinCat(Presentation{T, Symbol}(Catlab.Theories.FreeSchema, (Ob = Ob{:generator}[V, E], Hom = Hom{:generator}[src, tgt, refl], AttrType = AttrType{:generator}[], Attr = Attr{:generator}[]), Dict(:refl=&gt;(:Hom=&gt;3), :src=&gt;(:Hom=&gt;1), :V=&gt;(:Ob=&gt;1), :E=&gt;(:Ob=&gt;2), :tgt=&gt;(:Hom=&gt;2)), Pair[])), TypeCat(Catlab.CategoricalAlgebra.Diagrams.SimpleDiagram{AlgebraicInterfaces.id, Catlab.CategoricalAlgebra.FinCats.FinCatPresentation{Catlab.Theories.ThSchema.Meta.T, Union{Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Ob}, Union{Catlab.Theories.FreeSchema.Attr, Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Hom}}, D} where D&lt;:(Catlab.CategoricalAlgebra.Categories.Functor{&lt;:Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}, Catlab.CategoricalAlgebra.FinCats.FinCatPresentation{Catlab.Theories.ThSchema.Meta.T, Union{Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Ob}, Union{Catlab.Theories.FreeSchema.Attr, Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Hom}}}), QueryDiagramHom{AlgebraicInterfaces.id, Catlab.CategoricalAlgebra.FinCats.FinCatPresentation{Catlab.Theories.ThSchema.Meta.T, Union{Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Ob}, Union{Catlab.Theories.FreeSchema.Attr, Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Hom}}, Catlab.CategoricalAlgebra.FinCats.FinDomFunctorMap{Catlab.CategoricalAlgebra.FinCats.FinCatPresentation{Catlab.Theories.ThSchema.Meta.T, Union{Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Ob}, Union{Catlab.Theories.FreeSchema.Attr, Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Hom}}, Catlab.CategoricalAlgebra.FinCats.FinCatPresentation{Catlab.Theories.ThSchema.Meta.T, Union{Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Ob}, Union{Catlab.Theories.FreeSchema.Attr, Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Hom}}, Dict{Symbol, Catlab.Theories.FreeSchema.Ob{:generator}}, Dict{Any, Any}}, Φ, D} where {Φ&lt;:(Catlab.CategoricalAlgebra.Categories.Transformation{C, D, Dom, Codom} where {C&lt;:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}), D&lt;:Catlab.CategoricalAlgebra.Categories.Category, Dom&lt;:(Catlab.CategoricalAlgebra.Categories.Functor{Dom} where Dom&lt;:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})), Codom&lt;:(Catlab.CategoricalAlgebra.Categories.Functor{Dom} where Dom&lt;:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}))}), D&lt;:(Catlab.CategoricalAlgebra.Categories.Functor{&lt;:Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}, Catlab.CategoricalAlgebra.FinCats.FinCatPresentation{Catlab.Theories.ThSchema.Meta.T, Union{Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Ob}, Union{Catlab.Theories.FreeSchema.Attr, Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Hom}}})})), Dict{Any, Union{}}())</code></pre><p>This is a migration from <code>SchReflexiveGraph</code> to <code>SchGraph</code>. Every call to <code>@migration</code> constructs a <em>contravariant</em> data migration, which means in this case that <code>M</code> will turn graphs into reflexive graphs. To construct <code>M</code>, we construct a functor whose domain is <code>SchReflexiveGraph</code>. The codomain is not just <code>SchGraph</code>, though! Before we get into that, let&#39;s understand what the syntax is signifying more concretely.</p><p>In general, each assignment statement <code>a =&gt; b</code> means &quot;when I migrate a graph <code>G</code> to a reflexive graph <code>H</code> with this migration, I want the <code>a</code> in <code>H</code> to be given by <code>b</code>.&quot; <code>b</code> will be some expression that makes sense in terms of the <em>original</em> graph <code>G</code>.</p><p>Thus the first line <code>V =&gt; V</code> is easy: we want the vertices of <code>H</code> to be the same as the vertices of <code>G</code>. For the second line, <code>E =&gt; @cases begin e::E; v::V end</code><code>things begin to get interesting. What this is saying is that we want an *edge* in</code>H<code>to be *either* an edge in</code>G<code>*or* a vertex in</code>G<code>. Thus both</code>E<code>and</code>V<code>refer to those sorts for</code>G<code>. The little</code>e<code>and</code>v` function as references for later.</p><p>Next we have to define our migration on the homs in <code>SchReflexiveGraph</code>. The line <code>src =&gt; begin e =&gt; src; v =&gt; id(V) end</code> says that we want the <code>src</code> function in our new reflexive graph <code>H</code> to be given by sending an edge to its original <code>src</code> and a vertex to itself. The <code>tgt</code> function of <code>H</code> behaves much the same. Finally, we need <code>refl</code> to be a function from <code>H</code>&#39;s <code>V</code> to <code>H</code>&#39;s <code>E</code>, and the only likely way to do that is to send a vertex to itself via <code>v</code>. (So you can think of <code>e</code> and <code>v</code> as the two inclusions into the coproduct, if you like.)</p><p>All in all, what have we done? Let&#39;s give it a try!</p><pre><code class="language-julia hljs">G = Graph(3)
H = migrate(ReflexiveGraph,G,M)</code></pre><div class="c-set">
<span class="c-set-summary">Catlab.Graphs.BasicGraphs.ReflexiveGraph {V:3, E:3}</span>
<table>
  <thead>
    <tr class = "header headerLastRow">
      <th class = "rowLabel" style = "font-weight: bold; text-align: right;">V</th>
      <th style = "text-align: right;">refl</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">1</td>
      <td style = "text-align: right;">1</td>
    </tr>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">2</td>
      <td style = "text-align: right;">2</td>
    </tr>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">3</td>
      <td style = "text-align: right;">3</td>
    </tr>
  </tbody>
</table>
<table>
  <thead>
    <tr class = "header headerLastRow">
      <th class = "rowLabel" style = "font-weight: bold; text-align: right;">E</th>
      <th style = "text-align: right;">src</th>
      <th style = "text-align: right;">tgt</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">1</td>
      <td style = "text-align: right;">1</td>
      <td style = "text-align: right;">1</td>
    </tr>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">2</td>
      <td style = "text-align: right;">2</td>
      <td style = "text-align: right;">2</td>
    </tr>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">3</td>
      <td style = "text-align: right;">3</td>
      <td style = "text-align: right;">3</td>
    </tr>
  </tbody>
</table>
</div>
<p>We see that <code>M</code> takes the discrete graph on 3 vertices to the discrete reflexive graph on 3 vertices; that is, <code>M</code> just adds a new loop to each vertex. And there&#39;s our first data migration!</p><p>That was an example of a <em>colimit</em> migration, in that in involved building a disjoint union, i.e. coproduct. Let&#39;s now look at an example of a limit migration. And why not make things look a bit more practical? Here&#39;s a schema for some tasks and workers, where we can assign times for a job to be done and a worker who&#39;s supposedly going to do that job at that time.</p><pre><code class="language-julia hljs">@present SchSchedule(FreeSchema) begin
  Jobs::Ob
  Workers::Ob
  assignment::Hom(Jobs,Workers)

  Time::AttrType
  time::Attr(Jobs,Time)
end
@acset_type Schedule(SchSchedule,index = [:assignment])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Main.Schedule</code></pre><p>Now let&#39;s construct a simple migration to find jobs assigned to the same worker at the same time.</p><pre><code class="language-julia hljs">@present SchConflicts(FreeSchema) begin
  ConflictedPairs::Ob
  Job1::Ob
  Job2::Ob
  Workers::Ob
  assignment::Hom(ConflictedPairs,Workers)
  job1::Hom(ConflictedPairs,Job1)
  job2::Hom(ConflictedPairs,Job2)

  Time::AttrType
  time::Attr(ConflictedPairs,Time)
end
@acset_type Conflicts(SchConflicts,index = [:assignment])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Main.Conflicts</code></pre><p>The key thing is going to be to construct the set of conflicted pairs: pairs (x,y) of jobs assigned to the same worker at the same time. This is a perfect job for a <em>limit</em> migration.</p><pre><code class="language-julia hljs">N = @migration SchConflicts SchSchedule begin
  ConflictedPairs =&gt; @join begin
                      X::Jobs
                      Y::Jobs
                      W::Workers
                      T::Time
                      (a:X→W)::assignment
                      (b:Y→W)::assignment
                      (t:X→T)::time
                      (s:Y→T)::time
  end
  Job1 =&gt; Jobs
  Job2 =&gt; Jobs
  Workers =&gt; Workers
  assignment =&gt; assignment(X)
  job1 =&gt; X
  job2 =&gt; Y
  Time =&gt; Time
  time =&gt; time(X)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">DataMigration{Catlab.CategoricalAlgebra.FinCats.FinDomFunctorMap{Catlab.CategoricalAlgebra.FinCats.FinCatPresentation{Catlab.Theories.ThSchema.Meta.T, Union{Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Ob}, Union{Catlab.Theories.FreeSchema.Attr, Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Hom}}, Catlab.CategoricalAlgebra.Categories.TypeCat{Catlab.CategoricalAlgebra.Diagrams.SimpleDiagram{GATlab.Stdlib.StdModels.op, Catlab.CategoricalAlgebra.FinCats.FinCatPresentation{Catlab.Theories.ThSchema.Meta.T, Union{Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Ob}, Union{Catlab.Theories.FreeSchema.Attr, Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Hom}}, D} where D&lt;:(Catlab.CategoricalAlgebra.Categories.Functor{&lt;:Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}, Catlab.CategoricalAlgebra.FinCats.FinCatPresentation{Catlab.Theories.ThSchema.Meta.T, Union{Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Ob}, Union{Catlab.Theories.FreeSchema.Attr, Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Hom}}}), Catlab.CategoricalAlgebra.Diagrams.SimpleDiagramHom{GATlab.Stdlib.StdModels.op, Catlab.CategoricalAlgebra.FinCats.FinCatPresentation{Catlab.Theories.ThSchema.Meta.T, Union{Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Ob}, Union{Catlab.Theories.FreeSchema.Attr, Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Hom}}, Catlab.CategoricalAlgebra.FinCats.FinDomFunctorMap{Catlab.CategoricalAlgebra.FinCats.FinCatPresentation{Catlab.Theories.ThSchema.Meta.T, Union{Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Ob}, Union{Catlab.Theories.FreeSchema.Attr, Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Hom}}, Catlab.CategoricalAlgebra.FinCats.FinCatPresentation{Catlab.Theories.ThSchema.Meta.T, Union{Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Ob}, Union{Catlab.Theories.FreeSchema.Attr, Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Hom}}, Dict{Symbol, Catlab.Theories.FreeSchema.Ob{:generator}}, Dict{Any, Any}}, Φ, Catlab.CategoricalAlgebra.FinCats.FinDomFunctorMap{Catlab.CategoricalAlgebra.FinCats.FinCatPresentation{Catlab.Theories.ThSchema.Meta.T, Union{Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Ob}, Union{Catlab.Theories.FreeSchema.Attr, Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Hom}}, Catlab.CategoricalAlgebra.FinCats.FinCatPresentation{Catlab.Theories.ThSchema.Meta.T, Union{Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Ob}, Union{Catlab.Theories.FreeSchema.Attr, Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Hom}}, Dict{Symbol, GATlab.Models.SymbolicModels.GATExpr{:generator}}, Dict{Symbol, GATlab.Models.SymbolicModels.GATExpr{:generator}}}} where Φ&lt;:(Catlab.CategoricalAlgebra.Categories.Transformation{C, D, Dom, Codom} where {C&lt;:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}), D&lt;:Catlab.CategoricalAlgebra.Categories.Category, Dom&lt;:(Catlab.CategoricalAlgebra.Categories.Functor{Dom} where Dom&lt;:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})), Codom&lt;:(Catlab.CategoricalAlgebra.Categories.Functor{Dom} where Dom&lt;:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}))})}, Dict{Symbol, Catlab.CategoricalAlgebra.Diagrams.SimpleDiagram{GATlab.Stdlib.StdModels.op, Catlab.CategoricalAlgebra.FinCats.FinCatPresentation{Catlab.Theories.ThSchema.Meta.T, Union{Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Ob}, Union{Catlab.Theories.FreeSchema.Attr, Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Hom}}, D} where D&lt;:(Catlab.CategoricalAlgebra.Categories.Functor{&lt;:Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}, Catlab.CategoricalAlgebra.FinCats.FinCatPresentation{Catlab.Theories.ThSchema.Meta.T, Union{Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Ob}, Union{Catlab.Theories.FreeSchema.Attr, Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Hom}}})}, Dict{Symbol, Catlab.CategoricalAlgebra.Diagrams.SimpleDiagramHom{GATlab.Stdlib.StdModels.op, Catlab.CategoricalAlgebra.FinCats.FinCatPresentation{Catlab.Theories.ThSchema.Meta.T, Union{Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Ob}, Union{Catlab.Theories.FreeSchema.Attr, Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Hom}}, Catlab.CategoricalAlgebra.FinCats.FinDomFunctorMap{Catlab.CategoricalAlgebra.FinCats.FinCatPresentation{Catlab.Theories.ThSchema.Meta.T, Union{Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Ob}, Union{Catlab.Theories.FreeSchema.Attr, Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Hom}}, Catlab.CategoricalAlgebra.FinCats.FinCatPresentation{Catlab.Theories.ThSchema.Meta.T, Union{Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Ob}, Union{Catlab.Theories.FreeSchema.Attr, Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Hom}}, Dict{Symbol, Catlab.Theories.FreeSchema.Ob{:generator}}, Dict{Any, Any}}, Φ, Catlab.CategoricalAlgebra.FinCats.FinDomFunctorMap{Catlab.CategoricalAlgebra.FinCats.FinCatPresentation{Catlab.Theories.ThSchema.Meta.T, Union{Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Ob}, Union{Catlab.Theories.FreeSchema.Attr, Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Hom}}, Catlab.CategoricalAlgebra.FinCats.FinCatPresentation{Catlab.Theories.ThSchema.Meta.T, Union{Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Ob}, Union{Catlab.Theories.FreeSchema.Attr, Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Hom}}, Dict{Symbol, GATlab.Models.SymbolicModels.GATExpr{:generator}}, Dict{Symbol, GATlab.Models.SymbolicModels.GATExpr{:generator}}}} where Φ&lt;:(Catlab.CategoricalAlgebra.Categories.Transformation{C, D, Dom, Codom} where {C&lt;:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}), D&lt;:Catlab.CategoricalAlgebra.Categories.Category, Dom&lt;:(Catlab.CategoricalAlgebra.Categories.Functor{Dom} where Dom&lt;:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})), Codom&lt;:(Catlab.CategoricalAlgebra.Categories.Functor{Dom} where Dom&lt;:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}))})}}, Dict{Any, Union{}}}(FinDomFunctor(Dict{Symbol, Catlab.CategoricalAlgebra.Diagrams.SimpleDiagram{GATlab.Stdlib.StdModels.op, Catlab.CategoricalAlgebra.FinCats.FinCatPresentation{Catlab.Theories.ThSchema.Meta.T, Union{Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Ob}, Union{Catlab.Theories.FreeSchema.Attr, Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Hom}}, D} where D&lt;:(Catlab.CategoricalAlgebra.Categories.Functor{&lt;:Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}, Catlab.CategoricalAlgebra.FinCats.FinCatPresentation{Catlab.Theories.ThSchema.Meta.T, Union{Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Ob}, Union{Catlab.Theories.FreeSchema.Attr, Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Hom}}})}(:Job2 =&gt; Diagram{op}(FinFunctor(Dict{Symbol, Catlab.Theories.FreeSchema.Ob{:generator}}(:Jobs =&gt; Jobs), Dict{Symbol, Union{Catlab.Theories.FreeSchema.Attr, Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Hom}}(), FinCat(Presentation{T, Symbol}(Catlab.Theories.FreeSchema, (Ob = Ob{:generator}[Jobs], Hom = Hom{:generator}[], AttrType = AttrType{:generator}[], Attr = Attr{:generator}[]), Dict(:Jobs=&gt;(:Ob=&gt;1)), Pair[])), FinCat(Presentation{T, Symbol}(Catlab.Theories.FreeSchema, (Ob = Ob{:generator}[Jobs, Workers], Hom = Hom{:generator}[assignment], AttrType = AttrType{:generator}[Time], Attr = Attr{:generator}[time]), Dict(:Jobs=&gt;(:Ob=&gt;1), :Workers=&gt;(:Ob=&gt;2), :assignment=&gt;(:Hom=&gt;1), :Time=&gt;(:AttrType=&gt;1), :time=&gt;(:Attr=&gt;1)), Pair[])))), :Workers =&gt; Diagram{op}(FinFunctor(Dict{Symbol, Catlab.Theories.FreeSchema.Ob{:generator}}(:Workers =&gt; Workers), Dict{Symbol, Union{Catlab.Theories.FreeSchema.Attr, Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Hom}}(), FinCat(Presentation{T, Symbol}(Catlab.Theories.FreeSchema, (Ob = Ob{:generator}[Workers], Hom = Hom{:generator}[], AttrType = AttrType{:generator}[], Attr = Attr{:generator}[]), Dict(:Workers=&gt;(:Ob=&gt;1)), Pair[])), FinCat(Presentation{T, Symbol}(Catlab.Theories.FreeSchema, (Ob = Ob{:generator}[Jobs, Workers], Hom = Hom{:generator}[assignment], AttrType = AttrType{:generator}[Time], Attr = Attr{:generator}[time]), Dict(:Jobs=&gt;(:Ob=&gt;1), :Workers=&gt;(:Ob=&gt;2), :assignment=&gt;(:Hom=&gt;1), :Time=&gt;(:AttrType=&gt;1), :time=&gt;(:Attr=&gt;1)), Pair[])))), :Job1 =&gt; Diagram{op}(FinFunctor(Dict{Symbol, Catlab.Theories.FreeSchema.Ob{:generator}}(:Jobs =&gt; Jobs), Dict{Symbol, Union{Catlab.Theories.FreeSchema.Attr, Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Hom}}(), FinCat(Presentation{T, Symbol}(Catlab.Theories.FreeSchema, (Ob = Ob{:generator}[Jobs], Hom = Hom{:generator}[], AttrType = AttrType{:generator}[], Attr = Attr{:generator}[]), Dict(:Jobs=&gt;(:Ob=&gt;1)), Pair[])), FinCat(Presentation{T, Symbol}(Catlab.Theories.FreeSchema, (Ob = Ob{:generator}[Jobs, Workers], Hom = Hom{:generator}[assignment], AttrType = AttrType{:generator}[Time], Attr = Attr{:generator}[time]), Dict(:Jobs=&gt;(:Ob=&gt;1), :Workers=&gt;(:Ob=&gt;2), :assignment=&gt;(:Hom=&gt;1), :Time=&gt;(:AttrType=&gt;1), :time=&gt;(:Attr=&gt;1)), Pair[])))), :ConflictedPairs =&gt; Diagram{op}(FinFunctor(Dict{Symbol, GATlab.Models.SymbolicModels.GATExpr{:generator}}(:T =&gt; Time, :W =&gt; Workers, :X =&gt; Jobs, :Y =&gt; Jobs), Dict{Symbol, GATlab.Models.SymbolicModels.GATExpr{:generator}}(:a =&gt; assignment, :b =&gt; assignment, :s =&gt; time, :t =&gt; time), FinCat(Presentation{T, Symbol}(Catlab.Theories.FreeSchema, (Ob = Ob{:generator}[X, Y, W, T], Hom = Hom{:generator}[a, b, t, s], AttrType = AttrType{:generator}[], Attr = Attr{:generator}[]), Dict(:T=&gt;(:Ob=&gt;4), :a=&gt;(:Hom=&gt;1), :b=&gt;(:Hom=&gt;2), :s=&gt;(:Hom=&gt;4), :W=&gt;(:Ob=&gt;3), :X=&gt;(:Ob=&gt;1), :Y=&gt;(:Ob=&gt;2), :t=&gt;(:Hom=&gt;3)), Pair[])), FinCat(Presentation{T, Symbol}(Catlab.Theories.FreeSchema, (Ob = Ob{:generator}[Jobs, Workers], Hom = Hom{:generator}[assignment], AttrType = AttrType{:generator}[Time], Attr = Attr{:generator}[time]), Dict(:Jobs=&gt;(:Ob=&gt;1), :Workers=&gt;(:Ob=&gt;2), :assignment=&gt;(:Hom=&gt;1), :Time=&gt;(:AttrType=&gt;1), :time=&gt;(:Attr=&gt;1)), Pair[])))), :Time =&gt; Diagram{op}(FinFunctor(Dict{Symbol, Catlab.Theories.FreeSchema.AttrType{:generator}}(:Time =&gt; Time), Dict{Symbol, Union{Catlab.Theories.FreeSchema.Attr, Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Hom}}(), FinCat(Presentation{T, Symbol}(Catlab.Theories.FreeSchema, (Ob = Ob{:generator}[Time], Hom = Hom{:generator}[], AttrType = AttrType{:generator}[], Attr = Attr{:generator}[]), Dict(:Time=&gt;(:Ob=&gt;1)), Pair[])), FinCat(Presentation{T, Symbol}(Catlab.Theories.FreeSchema, (Ob = Ob{:generator}[Jobs, Workers], Hom = Hom{:generator}[assignment], AttrType = AttrType{:generator}[Time], Attr = Attr{:generator}[time]), Dict(:Jobs=&gt;(:Ob=&gt;1), :Workers=&gt;(:Ob=&gt;2), :assignment=&gt;(:Hom=&gt;1), :Time=&gt;(:AttrType=&gt;1), :time=&gt;(:Attr=&gt;1)), Pair[]))))), Dict{Symbol, Catlab.CategoricalAlgebra.Diagrams.SimpleDiagramHom{GATlab.Stdlib.StdModels.op, Catlab.CategoricalAlgebra.FinCats.FinCatPresentation{Catlab.Theories.ThSchema.Meta.T, Union{Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Ob}, Union{Catlab.Theories.FreeSchema.Attr, Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Hom}}, Catlab.CategoricalAlgebra.FinCats.FinDomFunctorMap{Catlab.CategoricalAlgebra.FinCats.FinCatPresentation{Catlab.Theories.ThSchema.Meta.T, Union{Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Ob}, Union{Catlab.Theories.FreeSchema.Attr, Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Hom}}, Catlab.CategoricalAlgebra.FinCats.FinCatPresentation{Catlab.Theories.ThSchema.Meta.T, Union{Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Ob}, Union{Catlab.Theories.FreeSchema.Attr, Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Hom}}, Dict{Symbol, Catlab.Theories.FreeSchema.Ob{:generator}}, Dict{Any, Any}}, Φ, Catlab.CategoricalAlgebra.FinCats.FinDomFunctorMap{Catlab.CategoricalAlgebra.FinCats.FinCatPresentation{Catlab.Theories.ThSchema.Meta.T, Union{Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Ob}, Union{Catlab.Theories.FreeSchema.Attr, Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Hom}}, Catlab.CategoricalAlgebra.FinCats.FinCatPresentation{Catlab.Theories.ThSchema.Meta.T, Union{Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Ob}, Union{Catlab.Theories.FreeSchema.Attr, Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Hom}}, Dict{Symbol, GATlab.Models.SymbolicModels.GATExpr{:generator}}, Dict{Symbol, GATlab.Models.SymbolicModels.GATExpr{:generator}}}} where Φ&lt;:(Catlab.CategoricalAlgebra.Categories.Transformation{C, D, Dom, Codom} where {C&lt;:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}), D&lt;:Catlab.CategoricalAlgebra.Categories.Category, Dom&lt;:(Catlab.CategoricalAlgebra.Categories.Functor{Dom} where Dom&lt;:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})), Codom&lt;:(Catlab.CategoricalAlgebra.Categories.Functor{Dom} where Dom&lt;:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}))})}(:job1 =&gt; DiagramHom{op}([(X, id(Jobs))], [], FinFunctor(Dict{Symbol, GATExpr{:generator}}(:T=&gt;Time, :W=&gt;Workers, :X=&gt;Jobs, :Y=&gt;Jobs), Dict{Symbol, GATExpr{:generator}}(:a=&gt;assignment, :b=&gt;assignment, :s=&gt;time, :t=&gt;time), …), FinFunctor(Dict{Symbol, Ob{:generator}}(:Jobs=&gt;Jobs), Dict{Symbol, Union{Attr, AttrType, Hom}}(), …)), :assignment =&gt; DiagramHom{op}([(X, assignment)], [], FinFunctor(Dict{Symbol, GATExpr{:generator}}(:T=&gt;Time, :W=&gt;Workers, :X=&gt;Jobs, :Y=&gt;Jobs), Dict{Symbol, GATExpr{:generator}}(:a=&gt;assignment, :b=&gt;assignment, :s=&gt;time, :t=&gt;time), …), FinFunctor(Dict{Symbol, Ob{:generator}}(:Workers=&gt;Workers), Dict{Symbol, Union{Attr, AttrType, Hom}}(), …)), :job2 =&gt; DiagramHom{op}([(Y, id(Jobs))], [], FinFunctor(Dict{Symbol, GATExpr{:generator}}(:T=&gt;Time, :W=&gt;Workers, :X=&gt;Jobs, :Y=&gt;Jobs), Dict{Symbol, GATExpr{:generator}}(:a=&gt;assignment, :b=&gt;assignment, :s=&gt;time, :t=&gt;time), …), FinFunctor(Dict{Symbol, Ob{:generator}}(:Jobs=&gt;Jobs), Dict{Symbol, Union{Attr, AttrType, Hom}}(), …)), :time =&gt; DiagramHom{op}([(X, time)], [], FinFunctor(Dict{Symbol, GATExpr{:generator}}(:T=&gt;Time, :W=&gt;Workers, :X=&gt;Jobs, :Y=&gt;Jobs), Dict{Symbol, GATExpr{:generator}}(:a=&gt;assignment, :b=&gt;assignment, :s=&gt;time, :t=&gt;time), …), FinFunctor(Dict{Symbol, AttrType{:generator}}(:Time=&gt;Time), Dict{Symbol, Union{Attr, AttrType, Hom}}(), …))), FinCat(Presentation{T, Symbol}(Catlab.Theories.FreeSchema, (Ob = Ob{:generator}[ConflictedPairs, Job1, Job2, Workers], Hom = Hom{:generator}[assignment, job1, job2], AttrType = AttrType{:generator}[Time], Attr = Attr{:generator}[time]), Dict(:time=&gt;(:Attr=&gt;1), :Job2=&gt;(:Ob=&gt;3), :Workers=&gt;(:Ob=&gt;4), :assignment=&gt;(:Hom=&gt;1), :Job1=&gt;(:Ob=&gt;2), :ConflictedPairs=&gt;(:Ob=&gt;1), :job2=&gt;(:Hom=&gt;3), :Time=&gt;(:AttrType=&gt;1), :job1=&gt;(:Hom=&gt;2)), Pair[])), TypeCat(Catlab.CategoricalAlgebra.Diagrams.SimpleDiagram{GATlab.Stdlib.StdModels.op, Catlab.CategoricalAlgebra.FinCats.FinCatPresentation{Catlab.Theories.ThSchema.Meta.T, Union{Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Ob}, Union{Catlab.Theories.FreeSchema.Attr, Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Hom}}, D} where D&lt;:(Catlab.CategoricalAlgebra.Categories.Functor{&lt;:Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}, Catlab.CategoricalAlgebra.FinCats.FinCatPresentation{Catlab.Theories.ThSchema.Meta.T, Union{Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Ob}, Union{Catlab.Theories.FreeSchema.Attr, Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Hom}}}), Catlab.CategoricalAlgebra.Diagrams.SimpleDiagramHom{GATlab.Stdlib.StdModels.op, Catlab.CategoricalAlgebra.FinCats.FinCatPresentation{Catlab.Theories.ThSchema.Meta.T, Union{Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Ob}, Union{Catlab.Theories.FreeSchema.Attr, Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Hom}}, Catlab.CategoricalAlgebra.FinCats.FinDomFunctorMap{Catlab.CategoricalAlgebra.FinCats.FinCatPresentation{Catlab.Theories.ThSchema.Meta.T, Union{Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Ob}, Union{Catlab.Theories.FreeSchema.Attr, Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Hom}}, Catlab.CategoricalAlgebra.FinCats.FinCatPresentation{Catlab.Theories.ThSchema.Meta.T, Union{Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Ob}, Union{Catlab.Theories.FreeSchema.Attr, Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Hom}}, Dict{Symbol, Catlab.Theories.FreeSchema.Ob{:generator}}, Dict{Any, Any}}, Φ, Catlab.CategoricalAlgebra.FinCats.FinDomFunctorMap{Catlab.CategoricalAlgebra.FinCats.FinCatPresentation{Catlab.Theories.ThSchema.Meta.T, Union{Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Ob}, Union{Catlab.Theories.FreeSchema.Attr, Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Hom}}, Catlab.CategoricalAlgebra.FinCats.FinCatPresentation{Catlab.Theories.ThSchema.Meta.T, Union{Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Ob}, Union{Catlab.Theories.FreeSchema.Attr, Catlab.Theories.FreeSchema.AttrType, Catlab.Theories.FreeSchema.Hom}}, Dict{Symbol, GATlab.Models.SymbolicModels.GATExpr{:generator}}, Dict{Symbol, GATlab.Models.SymbolicModels.GATExpr{:generator}}}} where Φ&lt;:(Catlab.CategoricalAlgebra.Categories.Transformation{C, D, Dom, Codom} where {C&lt;:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}), D&lt;:Catlab.CategoricalAlgebra.Categories.Category, Dom&lt;:(Catlab.CategoricalAlgebra.Categories.Functor{Dom} where Dom&lt;:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})), Codom&lt;:(Catlab.CategoricalAlgebra.Categories.Functor{Dom} where Dom&lt;:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}))}))), Dict{Any, Union{}}())</code></pre><p>Most of this migration is easy enough, but the image of <code>ConflictedPairs</code><code>is quite complicated. We&#39;ve specified a *diagram* in</code>SchSchedule<code>, given by mapping the graph with vertices</code>X,Y,W,T<code>and edges</code>a,b,t,s` into that schema according to the mapping given to the right of the double colons.</p><p>What the <code>@join</code> decoration does is instruct the migration to send a <code>Schedule</code> <code>A</code><code>to a</code>Conflicts<code></code>B<code>whose</code>ConflictedPairs<code>are the set of all ways to choose an element of</code>A<code>&#39;s</code>Jobs<code>for</code>X<code>and for</code>Y<code>, an element of</code>A<code>&#39;s</code>Workers<code>for</code>W<code>, and an element of</code>A<code>&#39;s</code>Time<code>for</code>T<code>, in such a way that moving along any of the four edges sends one of the selected choices to another. What this amounts to is, as promised, all the ways to choose two jobs assigned the same worker and the same time. Let&#39;s see it in action. We&#39;ll use Julia&#39;s</code>Time<code>type for the</code>Time` attribute but for now, times will be on whole hours.</p><pre><code class="language-julia hljs">using Dates
A = @acset Schedule{Time} begin
  Jobs = 7
  Workers = 3
  assignment = [1,3,2,2,3,1,1]
  time = Time.([9,9,10,11,10,10,9])
end</code></pre><div class="c-set">
<span class="c-set-summary">Main.__atexample__named__migrations_intro.Schedule{Dates.Time} {Jobs:7, Workers:3, Time:0}</span>
<table>
  <thead>
    <tr class = "header headerLastRow">
      <th class = "rowLabel" style = "font-weight: bold; text-align: right;">Jobs</th>
      <th style = "text-align: right;">assignment</th>
      <th style = "text-align: right;">time</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">1</td>
      <td style = "text-align: right;">1</td>
      <td style = "text-align: right;">09:00:00</td>
    </tr>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">2</td>
      <td style = "text-align: right;">3</td>
      <td style = "text-align: right;">09:00:00</td>
    </tr>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">3</td>
      <td style = "text-align: right;">2</td>
      <td style = "text-align: right;">10:00:00</td>
    </tr>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">4</td>
      <td style = "text-align: right;">2</td>
      <td style = "text-align: right;">11:00:00</td>
    </tr>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">5</td>
      <td style = "text-align: right;">3</td>
      <td style = "text-align: right;">10:00:00</td>
    </tr>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">6</td>
      <td style = "text-align: right;">1</td>
      <td style = "text-align: right;">10:00:00</td>
    </tr>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">7</td>
      <td style = "text-align: right;">1</td>
      <td style = "text-align: right;">09:00:00</td>
    </tr>
  </tbody>
</table>
</div>
<p>You can probably spot that we ought to get one conflict, since worker 1 is supposed to be doing both jobs 1 and 7 at 9:00am. Let&#39;s check:</p><pre><code class="language-julia hljs">A′ = migrate(Conflicts,A,N)</code></pre><div class="c-set">
<span class="c-set-summary">Main.__atexample__named__migrations_intro.Conflicts{Dates.Time} {ConflictedPairs:9, Job1:7, Job2:7, Workers:3, Time:0}</span>
<table>
  <thead>
    <tr class = "header headerLastRow">
      <th class = "rowLabel" style = "font-weight: bold; text-align: right;">ConflictedPairs</th>
      <th style = "text-align: right;">assignment</th>
      <th style = "text-align: right;">job1</th>
      <th style = "text-align: right;">job2</th>
      <th style = "text-align: right;">time</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">1</td>
      <td style = "text-align: right;">1</td>
      <td style = "text-align: right;">1</td>
      <td style = "text-align: right;">1</td>
      <td style = "text-align: right;">09:00:00</td>
    </tr>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">2</td>
      <td style = "text-align: right;">1</td>
      <td style = "text-align: right;">1</td>
      <td style = "text-align: right;">7</td>
      <td style = "text-align: right;">09:00:00</td>
    </tr>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">3</td>
      <td style = "text-align: right;">3</td>
      <td style = "text-align: right;">2</td>
      <td style = "text-align: right;">2</td>
      <td style = "text-align: right;">09:00:00</td>
    </tr>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">4</td>
      <td style = "text-align: right;">2</td>
      <td style = "text-align: right;">3</td>
      <td style = "text-align: right;">3</td>
      <td style = "text-align: right;">10:00:00</td>
    </tr>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">5</td>
      <td style = "text-align: right;">2</td>
      <td style = "text-align: right;">4</td>
      <td style = "text-align: right;">4</td>
      <td style = "text-align: right;">11:00:00</td>
    </tr>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">6</td>
      <td style = "text-align: right;">3</td>
      <td style = "text-align: right;">5</td>
      <td style = "text-align: right;">5</td>
      <td style = "text-align: right;">10:00:00</td>
    </tr>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">7</td>
      <td style = "text-align: right;">1</td>
      <td style = "text-align: right;">6</td>
      <td style = "text-align: right;">6</td>
      <td style = "text-align: right;">10:00:00</td>
    </tr>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">8</td>
      <td style = "text-align: right;">1</td>
      <td style = "text-align: right;">7</td>
      <td style = "text-align: right;">1</td>
      <td style = "text-align: right;">09:00:00</td>
    </tr>
    <tr>
      <td class = "rowLabel" style = "font-weight: bold; text-align: right;">9</td>
      <td style = "text-align: right;">1</td>
      <td style = "text-align: right;">7</td>
      <td style = "text-align: right;">7</td>
      <td style = "text-align: right;">09:00:00</td>
    </tr>
  </tbody>
</table>
</div>
</article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« DataMigrations.jl</a><a class="docs-footer-nextpage" href="../../api/">Library Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Wednesday 18 December 2024 02:01">Wednesday 18 December 2024</span>. Using Julia version 1.11.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
