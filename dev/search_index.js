var documenterSearchIndex = {"docs":
[{"location":"api/#Library-Reference","page":"Library Reference","title":"Library Reference","text":"","category":"section"},{"location":"api/#DataMigrations.DataMigrations","page":"Library Reference","title":"DataMigrations.DataMigrations","text":"DataMigrations.jl\n\nExtends Catlab.jl with facilities for migrating  acsets (see Acsets.jl) to different  schemas via conjunctive, duc, and gluing queries. Such queries are determined by a functor on the  target schema valued in diagram categories of the target schema.\n\n\n\n\n\n","category":"module"},{"location":"api/#DataMigrations.Migrations","page":"Library Reference","title":"DataMigrations.Migrations","text":"Contravariant complex data migrations.\n\n\n\n\n\n","category":"module"},{"location":"api/#DataMigrations.Migrations.ConjQuery","page":"Library Reference","title":"DataMigrations.Migrations.ConjQuery","text":"A conjunctive query over schema C.\n\nWhen this query is used as part of a call to migrate, the diagram will be composed  with an acset and its limit will then be computed in Set.\n\nSee also: GlueQuery, GlucQuery\n\n\n\n\n\n","category":"type"},{"location":"api/#DataMigrations.Migrations.ConjSchemaMigration","page":"Library Reference","title":"DataMigrations.Migrations.ConjSchemaMigration","text":"Schema-level functor defining a contravariant data migration using conjunctive queries.\n\n\n\n\n\n","category":"type"},{"location":"api/#DataMigrations.Migrations.DataMigration","page":"Library Reference","title":"DataMigrations.Migrations.DataMigration","text":"A contravariant data migration whose underlying functor F may not be fully defined. \n\nInstead, the migration F⋅X for an acset X can only be constructed once  we have access to X's attributes and homs. The dictionary of parameters contains anonymous  functions acting on X's attributes using Julia functions defined on  these attribute types.\n\n\n\n\n\n","category":"type"},{"location":"api/#DataMigrations.Migrations.GlucQuery","page":"Library Reference","title":"DataMigrations.Migrations.GlucQuery","text":"\"Gluc query\" (gluing of conjunctive queries) over schema C.\n\nThe diagram of diagrams comprising the query specifies a finite colimit of finite limits. In the important special case that the outer diagram has discrete shape, it specifies a finite coproduct of finite limits and the query is called a \"duc query\" (disjoint union of conjunctive queries).\n\nSee also: GlueQuery, GlucQuery\n\n\n\n\n\n","category":"type"},{"location":"api/#DataMigrations.Migrations.GlucSchemaMigration","page":"Library Reference","title":"DataMigrations.Migrations.GlucSchemaMigration","text":"Schema-level functor defining a contravariant data migration using gluc queries.\n\n\n\n\n\n","category":"type"},{"location":"api/#DataMigrations.Migrations.GlueQuery","page":"Library Reference","title":"DataMigrations.Migrations.GlueQuery","text":"Gluing or agglomerative query over schema C.\n\nThe diagram comprising the query specifies a finite colimit. In the important special case that the diagram has discrete shape, it specifies a finite coproduct and the query is called \"linear\" or \"disjunctive\".\n\nSee also: ConjQuery, GlucQuery\n\n\n\n\n\n","category":"type"},{"location":"api/#DataMigrations.Migrations.GlueSchemaMigration","page":"Library Reference","title":"DataMigrations.Migrations.GlueSchemaMigration","text":"Schema-level functor defining a contravariant data migration using gluing queries.\n\n\n\n\n\n","category":"type"},{"location":"api/#DataMigrations.Migrations.QueryDiagram","page":"Library Reference","title":"DataMigrations.Migrations.QueryDiagram","text":"A diagram representing a (conjunctive, duc, gluing, or gluc) query.\n\nBesides the diagram functor itself, a QueryDiagram contains a  dictionary params of query parameters.  The keys of params are the hom_generators of the target schema C on which the diagram is not fully defined until a migration is executed. The values are either Functions or constants. If Functions, then these values will have one argument for each hom_generator of the target schema D  and return a further function of one argument.\n\nWhen an ACSet X is migrated via a QueryDiagram,  the Functions in params are evaluated on the  FinDomFunctions in X's range, and the resulting one-variable functions are either pasted directly into the  migrated ACSet Y, or else composed with intermediate FinDomFunctions defined by migrating X using only the inner diagram. If the keys of params are constants then Y will receive constant attributes at the  corresponding values.\n\n\n\n\n\n","category":"type"},{"location":"api/#DataMigrations.Migrations.QueryDiagram-Union{Tuple{P}, Tuple{D}, Tuple{C}, Tuple{T}, Tuple{D, P}} where {T, C<:Catlab.CategoricalAlgebra.Categories.Category, D<:(Catlab.CategoricalAlgebra.Categories.Functor{<:Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}, C}), P}","page":"Library Reference","title":"DataMigrations.Migrations.QueryDiagram","text":"QueryDiagram{T}(F,params)\n\nConstruct a QueryDiagram based on the Functor F and with parameter dictionary params. \n\nThe type parameter T may be id, op, or possibly co or Any, though not all functionality is defined for co and not all functionality is definable for Any. Other type parameters are inferred from  the type of F. The type C of the codomain F will in practice be a subtype of FinCat or of  Diagram{T}. \n\n\n\n\n\n","category":"method"},{"location":"api/#DataMigrations.Migrations.QueryDiagramHom","page":"Library Reference","title":"DataMigrations.Migrations.QueryDiagramHom","text":"A DiagramHom that may be partially-defined, to be evaluated later using the dictionary params of parameters.\n\nAs with QueryDiagrams, params will be a dictionary of Functions or perhaps constants. A QueryDiagramHom is expected to live inside a DataMigration M and to be fully evaluated whenever migrate is called on M and some ACSet X. \n\nHow this works is that the partially-defined DiagramHom consisting of shape_map, diagram_map, and precomposed_diagram is whiskered with X (except where it's undefined),  and then the functions in params are used to fill in the gaps.\n\nSee also QueryDiagram\n\n\n\n\n\n","category":"type"},{"location":"api/#DataMigrations.Migrations.QueryDiagramHom-Union{Tuple{Params}, Tuple{D}, Tuple{Φ}, Tuple{F}, Tuple{C}, Tuple{T}, Tuple{F, Φ, D, Params}} where {T, C, F<:(Catlab.CategoricalAlgebra.Categories.Functor{Dom, Codom} where {Dom<:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}), Codom<:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})}), Φ<:(Catlab.CategoricalAlgebra.Categories.Transformation{C, D, Dom, Codom} where {C<:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}), D<:Catlab.CategoricalAlgebra.Categories.Category, Dom<:(Catlab.CategoricalAlgebra.Categories.Functor{Dom} where Dom<:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})), Codom<:(Catlab.CategoricalAlgebra.Categories.Functor{Dom} where Dom<:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}))}), D<:(Catlab.CategoricalAlgebra.Categories.Functor{<:Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}, C}), Params<:AbstractDict}","page":"Library Reference","title":"DataMigrations.Migrations.QueryDiagramHom","text":"QueryDiagramHom{T}(shape_map, diagram_map, precomposed_diagram, params)\n\nConstruct a QueryDiagramHom of variance T and fields the given arguments, with further type parameters inferred.\n\n\n\n\n\n","category":"method"},{"location":"api/#DataMigrations.Migrations.QueryDiagramHom-Union{Tuple{Params}, Tuple{T}, Tuple{Params, Vararg{Any}}} where {T, Params<:AbstractDict}","page":"Library Reference","title":"DataMigrations.Migrations.QueryDiagramHom","text":"QueryDiagramHom{T}(params,args...)\n\nBuild a QueryDiagramHom with variance T by first building a DiagramHom using args..., then adding the params. \n\nThere are many methods of DiagramHom allowing various calling conventions, and this allows QueryDiagramHom to steal them all reasonably efficiently.\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicInterfaces.compose-Union{Tuple{T}, Tuple{DiagramHom{T}, Catlab.CategoricalAlgebra.Categories.Functor, Any}} where T","page":"Library Reference","title":"AlgebraicInterfaces.compose","text":"compose(f::DiagramHom,F::Functor,params[;kw...])\n\nWhisker a partially-defined DiagramHom with a  Functor, using the dictionary params to fill in any gaps. \n\nWhile QueryDiagramHoms have internal params for a similar purpose, it is sometimes necessary to borrow params from a QueryDiagram containing f, which is the functionality enabled here.\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicInterfaces.compose-Union{Tuple{T}, Tuple{QueryDiagram{T, C} where C<:Catlab.CategoricalAlgebra.Categories.Category, Catlab.CategoricalAlgebra.Categories.Functor}} where T","page":"Library Reference","title":"AlgebraicInterfaces.compose","text":"compose(d::QueryDiagram,F::Functor[;kw...])\n\nLazily compose a diagram with parameters (see QueryDiagram)  with a Functor. \n\nThe result is not evaluated, so the  returned QueryDiagram may remain partially defined with parameters  still to be filled in.\n\nSee also: force, QueryDiagram\n\n\n\n\n\n","category":"method"},{"location":"api/#Catlab.CategoricalAlgebra.FinCats.force","page":"Library Reference","title":"Catlab.CategoricalAlgebra.FinCats.force","text":"force(F::FinDomFunctor,params,[Obtype=Any,Homtype=Any])\n\nForce-evaluate a partially-defined FinDomFunctor by using Functions in params to fill in undefined  entries of F's hom_map.\n\nIf Obtype and Homtype are specified, then the returned functor is guaranteed to have exactly those value types in its ob_map and hom_map.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catlab.CategoricalAlgebra.FinCats.force-Union{Tuple{T}, Tuple{QueryDiagram{T, C} where C<:Catlab.CategoricalAlgebra.Categories.Category, Vararg{Any}}} where T","page":"Library Reference","title":"Catlab.CategoricalAlgebra.FinCats.force","text":"force(d::QueryDiagram,[args...])\n\nForce-evaluate the d.diagram for a QueryDiagram d.\n\nThe result is a SimpleDiagram, and in particular the inner call to force attempts to use d.params to produce a fully-defined FinDomFunctor.\n\n\n\n\n\n","category":"method"},{"location":"api/#Catlab.CategoricalAlgebra.FunctorialDataMigrations.migrate-Tuple{Catlab.CategoricalAlgebra.Categories.Functor{Dom} where Dom<:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}), Catlab.CategoricalAlgebra.FunctorialDataMigrations.ContravariantMigration{<:Catlab.CategoricalAlgebra.Categories.Functor{D, <:Catlab.CategoricalAlgebra.Categories.TypeCat{<:Catlab.CategoricalAlgebra.Diagrams.Diagram{AlgebraicInterfaces.id, <:Catlab.CategoricalAlgebra.Categories.TypeCat{<:Catlab.CategoricalAlgebra.Diagrams.Diagram{GATlab.Stdlib.StdModels.op, C}}}}}} where {D<:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}), C<:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})}}","page":"Library Reference","title":"Catlab.CategoricalAlgebra.FunctorialDataMigrations.migrate","text":"migrate(M,X)\n\ndo the dang migration\n\n\n\n\n\n","category":"method"},{"location":"api/#DataMigrations.Migrations.colimit_representables-Tuple{Catlab.CategoricalAlgebra.FunctorialDataMigrations.ContravariantMigration{F} where F<:(Catlab.CategoricalAlgebra.Categories.Functor{Dom, Codom} where {Dom<:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}), Codom<:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})}), Any}","page":"Library Reference","title":"DataMigrations.Migrations.colimit_representables","text":"Interpret conjunctive data migration as a colimit of representables.\n\nGiven a conjunctive data migration (a functor J → Diag{op}(C)) and the Yoneda embedding for C (a functor op(C) → C-Set computed via yoneda), take colimits of representables to construct a op(J)-shaped diagram of C-sets.\n\nSince every C-set is a colimit of representables, this is a generic way of constructing diagrams of C-sets.\n\n\n\n\n\n","category":"method"},{"location":"api/#DataMigrations.Migrations.get_params-Tuple{QueryDiagramHom}","page":"Library Reference","title":"DataMigrations.Migrations.get_params","text":"get_params(f::DiagramHom)\n\nGet the parameters of f, if f is a QueryDiagramHom. Otherwise return an empty Dict.\n\n\n\n\n\n","category":"method"},{"location":"api/#DataMigrations.Migrations.get_src_schema-Tuple{Catlab.CategoricalAlgebra.Categories.Functor{<:Catlab.CategoricalAlgebra.Categories.Category, <:Catlab.CategoricalAlgebra.Categories.TypeCat{<:Catlab.CategoricalAlgebra.Diagrams.Diagram}}}","page":"Library Reference","title":"DataMigrations.Migrations.get_src_schema","text":"Get the source schema of a data migration functor, recursing in the case that the proximate codomain is a diagram category.\n\n\n\n\n\n","category":"method"},{"location":"api/#DataMigrations.Migrations.param_compose-Tuple{Catlab.CategoricalAlgebra.Categories.Transformation{C, D, Dom, Codom} where {C<:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}), D<:Catlab.CategoricalAlgebra.Categories.Category, Dom<:(Catlab.CategoricalAlgebra.Categories.Functor{Dom} where Dom<:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom})), Codom<:(Catlab.CategoricalAlgebra.Categories.Functor{Dom} where Dom<:(Catlab.CategoricalAlgebra.Categories.Category{Ob, Hom, Catlab.CategoricalAlgebra.FinCats.FinCatSize} where {Ob, Hom}))}, Catlab.CategoricalAlgebra.Categories.Functor, Any}","page":"Library Reference","title":"DataMigrations.Migrations.param_compose","text":"param_compose(α,H,params)\n\nWhisker a partially natural transformation α with a functor H, given any needed parameters params specifying the functions in  H's codomain which the whiskered result should map to. \n\nCurrently assumes the result will be a totally defined transformation.\n\n\n\n\n\n","category":"method"},{"location":"api/#DataMigrations.DiagrammaticPrograms.@acset_colim-Tuple{Any, Any}","page":"Library Reference","title":"DataMigrations.DiagrammaticPrograms.@acset_colim","text":"Uses the output of yoneda:\n\n@acset_colim yGraph begin    (e1,e2)::E    src(e1) == tgt(e2)  end\n\n\n\n\n\n","category":"macro"},{"location":"api/#DataMigrations.DiagrammaticPrograms.@diagram-Tuple{Any, Any}","page":"Library Reference","title":"DataMigrations.DiagrammaticPrograms.@diagram","text":"Present a diagram in a given category.\n\nRecall that a diagram in a category C is a functor F J  C from a small category J into C. Given the category C, this macro presents a diagram in C, i.e., constructs a finitely presented indexing category J together with a functor F J  C. This method of simultaneous definition is often more convenient than defining J and F separately, as could be accomplished by calling @fincat and then @finfunctor.\n\nAs an example, the limit of the following diagram consists of the paths of length two in a graph:\n\n@diagram SchGraph begin\n  v::V\n  (e₁, e₂)::E\n  (t: e₁ → v)::tgt\n  (s: e₂ → v)::src\nend\n\nMorphisms in the indexing category can be left unnamed, which is convenient for defining free diagrams (see also @free_diagram). For example, the following diagram is isomorphic to the previous one:\n\n@diagram SchGraph begin\n  v::V\n  (e₁, e₂)::E\n  (e₁ → v)::tgt\n  (e₂ → v)::src\nend\n\nOf course, unnamed morphisms cannot be referenced by name within the @diagram call or in other settings, which can sometimes be problematic.\n\n\n\n\n\n","category":"macro"},{"location":"api/#DataMigrations.DiagrammaticPrograms.@fincat-Tuple{Any}","page":"Library Reference","title":"DataMigrations.DiagrammaticPrograms.@fincat","text":"Present a category by generators and relations.\n\nThe result is a finitely presented category (FinCat) represented by a graph, possibly with path equations. For example, the simplex category truncated to one dimension is:\n\n@fincat begin\n  V, E\n  (δ₀, δ₁): V → E\n  σ₀: E → V\n\n  σ₀ ∘ δ₀ == id(V)\n  σ₀ ∘ δ₁ == id(V)\nend\n\nThe objects and morphisms must be uniquely named.\n\n\n\n\n\n","category":"macro"},{"location":"api/#DataMigrations.DiagrammaticPrograms.@finfunctor-NTuple{4, Any}","page":"Library Reference","title":"DataMigrations.DiagrammaticPrograms.@finfunctor","text":"Define a functor between two finitely presented categories.\n\nSuch a functor is defined by sending the object and morphism generators of the domain category to generic object and morphism expressions in the codomain category. For example, the following functor embeds the schema for graphs into the schema for circular port graphs by ignoring the ports:\n\n@finfunctor SchGraph SchCPortGraph begin\n  V => Box\n  E => Wire\n  src => src ⨟ box\n  tgt => tgt ⨟ box\nend\n\nA constructor exists that purports to allow the user to check that a proposed functor satisfies relations in the domain, but this functionality doesn't yet exist (and the problem is undecidable in general.) Thus the only check is that the source and target of the image of an arrow are the image of its source and target.\n\n\n\n\n\n","category":"macro"},{"location":"api/#DataMigrations.DiagrammaticPrograms.@free_diagram-Tuple{Any, Any}","page":"Library Reference","title":"DataMigrations.DiagrammaticPrograms.@free_diagram","text":"Present a free diagram in a given category.\n\nRecall that a free diagram in a category C is a functor F J  C where J is a free category on a graph, here assumed finite. This macro is functionally a special case of @diagram but changes the interpretation of equality expressions. Rather than interpreting them as equations between morphisms in J, equality expresions can be used to introduce anonymous morphisms in a \"pointful\" style. For example, the limit of the following diagram consists of the paths of length two in a graph:\n\n@free_diagram SchGraph begin\n  v::V\n  (e₁, e₂)::E\n  tgt(e₁) == v\n  src(e₂) == v\nend\n\nAnonymous objects can also be introduced. For example, the previous diagram is isomorphic to this one:\n\n@free_diagram SchGraph begin\n  (e₁, e₂)::E\n  tgt(e₁) == src(e₂)\nend\n\nSome care must exercised when defining morphisms between diagrams with anonymous objects, since they cannot be referred to by name.\n\n\n\n\n\n","category":"macro"},{"location":"api/#DataMigrations.DiagrammaticPrograms.@graph-Tuple{Any, Any}","page":"Library Reference","title":"DataMigrations.DiagrammaticPrograms.@graph","text":"Construct a graph in a simple, declarative style.\n\nThe syntax is reminiscent of Graphviz. Each line a declares a vertex or set of vertices, or an edge. For example, the following defines a directed triangle:\n\n@graph begin\n  v0, v1, v2\n  fst: v0 → v1\n  snd: v1 → v2\n  comp: v0 → v2\nend\n\nVertices in the graph must be uniquely named, whereas edges names are optional.\n\n\n\n\n\n","category":"macro"},{"location":"api/#DataMigrations.DiagrammaticPrograms.@migrate-Tuple{Any, Any, Any}","page":"Library Reference","title":"DataMigrations.DiagrammaticPrograms.@migrate","text":"Contravariantly migrate data from one acset to another.\n\nThis macro is shorthand for defining a data migration using the @migration macro and then calling the migrate function. If the migration will be used multiple times, it is more efficient to perform these steps separately, reusing the functor defined by @migration.\n\nFor more about the syntax and supported features, see @migration.\n\n\n\n\n\n","category":"macro"},{"location":"api/#DataMigrations.DiagrammaticPrograms.@migration-Tuple{Any, Any}","page":"Library Reference","title":"DataMigrations.DiagrammaticPrograms.@migration","text":"Define a contravariant data migration.\n\nThis macro provides a DSL to specify a contravariant data migration from C-sets to D-sets for given schemas C and D. A data migration is defined by a functor from D to a category of queries on C. Thus, every object of D is assigned a query on C and every morphism of D is assigned a morphism of queries, in a compatible way. Example usages are in the unit tests. What follows is a technical reference.\n\nSeveral categories of queries are supported by this macro:\n\nTrivial queries, specified by a single object of C. In this case, the macro simply defines a functor D  C and is equivalent to @finfunctor or @diagram.\nConjunctive queries, specified by a diagram in C and evaluated as a finite limit.\nGluing queries, specified by a diagram in C and evaluated as a finite colimit. An important special case is linear queries, evaluated as a finite coproduct.\nGluc queries (gluings of conjunctive queries), specified by a diagram of diagrams in C and evaluated as a colimit of limits. An important special case is duc queries (disjoint unions of conjunctive queries), evaluated as a coproduct of limits.\n\nThe query category of the data migration is not specified explicitly but is inferred from the queries used in the macro call. Implicit conversion is performed: trivial queries can be coerced to conjunctive queries or gluing queries, and conjunctive queries and gluing queries can both be coerced to gluc queries. Due to the implicit conversion, the resulting functor out of D has a single query type and thus a well-defined codomain.\n\nSyntax for the right-hand sides of object assignments is:\n\na symbol, giving object of C (query type: trivial)\n@product ... (query type: conjunctive)\n@unit (alias: @terminal, query type: conjunctive)\n@join ... (alias: @limit, query type: conjunctive)\n@cases ... (alias: @coproduct, query type: gluing)\n@empty (alias: @initial, query type: gluing)\n@glue ... (alias: @colimit, query type: gluing)\n\nThes query types supported by this macro generalize the kind of queries familiar from relational databases. Less familiar is the concept of a morphism between queries, derived from the concept of a morphism between diagrams in a category. A query morphism is given by a functor between the diagrams' indexing categories together with a natural transformation filling a triangle of the appropriate shape. From a practical standpoint, the most important thing to remember is that a morphism between conjunctive queries is contravariant with respect to the diagram shapes, whereas a morphism between gluing queries is covariant. TODO: Reference for more on this.\n\n\n\n\n\n","category":"macro"},{"location":"generated/migrations_intro/#Introduction-to-Data-Migrations","page":"Introduction to Data Migrations","title":"Introduction to Data Migrations","text":"","category":"section"},{"location":"generated/migrations_intro/","page":"Introduction to Data Migrations","title":"Introduction to Data Migrations","text":"DataMigrations.jl includes facilities for categorical data migrations. We'll start by example, working with some graph schemas from Catlab.","category":"page"},{"location":"generated/migrations_intro/","page":"Introduction to Data Migrations","title":"Introduction to Data Migrations","text":"using Catlab, DataMigrations\nM = @migration SchReflexiveGraph SchGraph begin\n  V => V\n  E => @cases begin e::E; v::V end\n  src => begin e => src; v => id(V) end\n  tgt => begin e => tgt; v => id(V) end\n  refl => v\nend","category":"page"},{"location":"generated/migrations_intro/","page":"Introduction to Data Migrations","title":"Introduction to Data Migrations","text":"This is a migration from SchReflexiveGraph to SchGraph. Every call to @migration constructs a contravariant data migration, which means in this case that M will turn graphs into reflexive graphs. To construct M, we construct a functor whose domain is SchReflexiveGraph. The codomain is not just SchGraph, though! Before we get into that, let's understand what the syntax is signifying more concretely.","category":"page"},{"location":"generated/migrations_intro/","page":"Introduction to Data Migrations","title":"Introduction to Data Migrations","text":"In general, each assignment statement a => b means \"when I migrate a graph G to a reflexive graph H with this migration, I want the a in H to be given by b.\" b will be some expression that makes sense in terms of the original graph G.","category":"page"},{"location":"generated/migrations_intro/","page":"Introduction to Data Migrations","title":"Introduction to Data Migrations","text":"Thus the first line V => V is easy: we want the vertices of H to be the same as the vertices of G. For the second line, E => @cases begin e::E; v::V endthings begin to get interesting. What this is saying is that we want an *edge* inHto be *either* an edge inG*or* a vertex inG. Thus bothEandVrefer to those sorts forG. The littleeandv` function as references for later.","category":"page"},{"location":"generated/migrations_intro/","page":"Introduction to Data Migrations","title":"Introduction to Data Migrations","text":"Next we have to define our migration on the homs in SchReflexiveGraph. The line src => begin e => src; v => id(V) end says that we want the src function in our new reflexive graph H to be given by sending an edge to its original src and a vertex to itself. The tgt function of H behaves much the same. Finally, we need refl to be a function from H's V to H's E, and the only likely way to do that is to send a vertex to itself via v. (So you can think of e and v as the two inclusions into the coproduct, if you like.)","category":"page"},{"location":"generated/migrations_intro/","page":"Introduction to Data Migrations","title":"Introduction to Data Migrations","text":"All in all, what have we done? Let's give it a try!","category":"page"},{"location":"generated/migrations_intro/","page":"Introduction to Data Migrations","title":"Introduction to Data Migrations","text":"G = Graph(3)\nH = migrate(ReflexiveGraph,G,M)","category":"page"},{"location":"generated/migrations_intro/","page":"Introduction to Data Migrations","title":"Introduction to Data Migrations","text":"We see that M takes the discrete graph on 3 vertices to the discrete reflexive graph on 3 vertices; that is, M just adds a new loop to each vertex. And there's our first data migration!","category":"page"},{"location":"generated/migrations_intro/","page":"Introduction to Data Migrations","title":"Introduction to Data Migrations","text":"That was an example of a colimit migration, in that in involved building a disjoint union, i.e. coproduct. Let's now look at an example of a limit migration. And why not make things look a bit more practical? Here's a schema for some tasks and workers, where we can assign times for a job to be done and a worker who's supposedly going to do that job at that time.","category":"page"},{"location":"generated/migrations_intro/","page":"Introduction to Data Migrations","title":"Introduction to Data Migrations","text":"@present SchSchedule(FreeSchema) begin\n  Jobs::Ob\n  Workers::Ob\n  assignment::Hom(Jobs,Workers)\n\n  Time::AttrType\n  time::Attr(Jobs,Time)\nend\n@acset_type Schedule(SchSchedule,index = [:assignment])","category":"page"},{"location":"generated/migrations_intro/","page":"Introduction to Data Migrations","title":"Introduction to Data Migrations","text":"Now let's construct a simple migration to find jobs assigned to the same worker at the same time.","category":"page"},{"location":"generated/migrations_intro/","page":"Introduction to Data Migrations","title":"Introduction to Data Migrations","text":"@present SchConflicts(FreeSchema) begin\n  ConflictedPairs::Ob\n  Job1::Ob\n  Job2::Ob\n  Workers::Ob\n  assignment::Hom(ConflictedPairs,Workers)\n  job1::Hom(ConflictedPairs,Job1)\n  job2::Hom(ConflictedPairs,Job2)\n\n  Time::AttrType\n  time::Attr(ConflictedPairs,Time)\nend\n@acset_type Conflicts(SchConflicts,index = [:assignment])","category":"page"},{"location":"generated/migrations_intro/","page":"Introduction to Data Migrations","title":"Introduction to Data Migrations","text":"The key thing is going to be to construct the set of conflicted pairs: pairs (x,y) of jobs assigned to the same worker at the same time. This is a perfect job for a limit migration.","category":"page"},{"location":"generated/migrations_intro/","page":"Introduction to Data Migrations","title":"Introduction to Data Migrations","text":"N = @migration SchConflicts SchSchedule begin\n  ConflictedPairs => @join begin\n                      X::Jobs\n                      Y::Jobs\n                      W::Workers\n                      T::Time\n                      (a:X→W)::assignment\n                      (b:Y→W)::assignment\n                      (t:X→T)::time\n                      (s:Y→T)::time\n  end\n  Job1 => Jobs\n  Job2 => Jobs\n  Workers => Workers\n  assignment => assignment(X)\n  job1 => X\n  job2 => Y\n  Time => Time\n  time => time(X)\nend","category":"page"},{"location":"generated/migrations_intro/","page":"Introduction to Data Migrations","title":"Introduction to Data Migrations","text":"Most of this migration is easy enough, but the image of ConflictedPairsis quite complicated. We've specified a *diagram* inSchSchedule, given by mapping the graph with verticesX,Y,W,Tand edgesa,b,t,s` into that schema according to the mapping given to the right of the double colons.","category":"page"},{"location":"generated/migrations_intro/","page":"Introduction to Data Migrations","title":"Introduction to Data Migrations","text":"What the @join decoration does is instruct the migration to send a Schedule Ato aConflictsBwhoseConflictedPairsare the set of all ways to choose an element ofA'sJobsforXand forY, an element ofA'sWorkersforW, and an element ofA'sTimeforT, in such a way that moving along any of the four edges sends one of the selected choices to another. What this amounts to is, as promised, all the ways to choose two jobs assigned the same worker and the same time. Let's see it in action. We'll use Julia'sTimetype for theTime` attribute but for now, times will be on whole hours.","category":"page"},{"location":"generated/migrations_intro/","page":"Introduction to Data Migrations","title":"Introduction to Data Migrations","text":"using Dates\nA = @acset Schedule{Time} begin\n  Jobs = 7\n  Workers = 3\n  assignment = [1,3,2,2,3,1,1]\n  time = Time.([9,9,10,11,10,10,9])\nend","category":"page"},{"location":"generated/migrations_intro/","page":"Introduction to Data Migrations","title":"Introduction to Data Migrations","text":"You can probably spot that we ought to get one conflict, since worker 1 is supposed to be doing both jobs 1 and 7 at 9:00am. Let's check:","category":"page"},{"location":"generated/migrations_intro/","page":"Introduction to Data Migrations","title":"Introduction to Data Migrations","text":"A′ = migrate(Conflicts,A,N)","category":"page"},{"location":"#DataMigrations.jl","page":"DataMigrations.jl","title":"DataMigrations.jl","text":"","category":"section"},{"location":"","page":"DataMigrations.jl","title":"DataMigrations.jl","text":"DataMigrations.jl is a Julia library for...","category":"page"}]
}
